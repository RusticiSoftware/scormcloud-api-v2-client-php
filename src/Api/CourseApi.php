<?php
/**
 * CourseApi
 * PHP version 7
 *
 * @category Class
 * @package  RusticiSoftware\Cloud\V2
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * SCORM Cloud Rest API
 *
 * REST API used for SCORM Cloud integrations.
 *
 * OpenAPI spec version: 2.0
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 2.4.12
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace RusticiSoftware\Cloud\V2\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use RusticiSoftware\Cloud\V2\ApiException;
use RusticiSoftware\Cloud\V2\Configuration;
use RusticiSoftware\Cloud\V2\HeaderSelector;
use RusticiSoftware\Cloud\V2\ObjectSerializer;

/**
 * CourseApi Class Doc Comment
 *
 * @category Class
 * @package  RusticiSoftware\Cloud\V2
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class CourseApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: Configuration::getDefaultConfiguration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation buildCoursePreviewLaunchLink
     *
     * Get a launch link to preview a Course
     *
     * @param  string $course_id course_id (required)
     * @param  \RusticiSoftware\Cloud\V2\Model\LaunchLinkRequestSchema $launch_link_request launch_link_request (required)
     *
     * @throws \RusticiSoftware\Cloud\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \RusticiSoftware\Cloud\V2\Model\LaunchLinkSchema
     */
    public function buildCoursePreviewLaunchLink($course_id, $launch_link_request)
    {
        list($response) = $this->buildCoursePreviewLaunchLinkWithHttpInfo($course_id, $launch_link_request);
        return $response;
    }

    /**
     * Operation buildCoursePreviewLaunchLinkWithHttpInfo
     *
     * Get a launch link to preview a Course
     *
     * @param  string $course_id (required)
     * @param  \RusticiSoftware\Cloud\V2\Model\LaunchLinkRequestSchema $launch_link_request (required)
     *
     * @throws \RusticiSoftware\Cloud\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \RusticiSoftware\Cloud\V2\Model\LaunchLinkSchema, HTTP status code, HTTP response headers (array of strings)
     */
    public function buildCoursePreviewLaunchLinkWithHttpInfo($course_id, $launch_link_request)
    {
        $returnType = '\RusticiSoftware\Cloud\V2\Model\LaunchLinkSchema';
        $request = $this->buildCoursePreviewLaunchLinkRequest($course_id, $launch_link_request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Cloud\V2\Model\LaunchLinkSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Cloud\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Cloud\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation buildCoursePreviewLaunchLinkAsync
     *
     * Get a launch link to preview a Course
     *
     * @param  string $course_id (required)
     * @param  \RusticiSoftware\Cloud\V2\Model\LaunchLinkRequestSchema $launch_link_request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function buildCoursePreviewLaunchLinkAsync($course_id, $launch_link_request)
    {
        return $this->buildCoursePreviewLaunchLinkAsyncWithHttpInfo($course_id, $launch_link_request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation buildCoursePreviewLaunchLinkAsyncWithHttpInfo
     *
     * Get a launch link to preview a Course
     *
     * @param  string $course_id (required)
     * @param  \RusticiSoftware\Cloud\V2\Model\LaunchLinkRequestSchema $launch_link_request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function buildCoursePreviewLaunchLinkAsyncWithHttpInfo($course_id, $launch_link_request)
    {
        $returnType = '\RusticiSoftware\Cloud\V2\Model\LaunchLinkSchema';
        $request = $this->buildCoursePreviewLaunchLinkRequest($course_id, $launch_link_request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'buildCoursePreviewLaunchLink'
     *
     * @param  string $course_id (required)
     * @param  \RusticiSoftware\Cloud\V2\Model\LaunchLinkRequestSchema $launch_link_request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function buildCoursePreviewLaunchLinkRequest($course_id, $launch_link_request)
    {
        // verify the required parameter 'course_id' is set
        if ($course_id === null || (is_array($course_id) && count($course_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $course_id when calling buildCoursePreviewLaunchLink'
            );
        }
        // verify the required parameter 'launch_link_request' is set
        if ($launch_link_request === null || (is_array($launch_link_request) && count($launch_link_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $launch_link_request when calling buildCoursePreviewLaunchLink'
            );
        }

        $resourcePath = '/courses/{courseId}/preview';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($course_id !== null) {
            $resourcePath = str_replace(
                '{' . 'courseId' . '}',
                ObjectSerializer::toPathValue($course_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($launch_link_request)) {
            $_tempBody = $launch_link_request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;

            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation buildCoursePreviewLaunchLinkWithVersion
     *
     * Get a launch link to preview a Course Version
     *
     * @param  string $course_id course_id (required)
     * @param  int $version_id version_id (required)
     * @param  \RusticiSoftware\Cloud\V2\Model\LaunchLinkRequestSchema $launch_link_request launch_link_request (required)
     *
     * @throws \RusticiSoftware\Cloud\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \RusticiSoftware\Cloud\V2\Model\LaunchLinkSchema
     */
    public function buildCoursePreviewLaunchLinkWithVersion($course_id, $version_id, $launch_link_request)
    {
        list($response) = $this->buildCoursePreviewLaunchLinkWithVersionWithHttpInfo($course_id, $version_id, $launch_link_request);
        return $response;
    }

    /**
     * Operation buildCoursePreviewLaunchLinkWithVersionWithHttpInfo
     *
     * Get a launch link to preview a Course Version
     *
     * @param  string $course_id (required)
     * @param  int $version_id (required)
     * @param  \RusticiSoftware\Cloud\V2\Model\LaunchLinkRequestSchema $launch_link_request (required)
     *
     * @throws \RusticiSoftware\Cloud\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \RusticiSoftware\Cloud\V2\Model\LaunchLinkSchema, HTTP status code, HTTP response headers (array of strings)
     */
    public function buildCoursePreviewLaunchLinkWithVersionWithHttpInfo($course_id, $version_id, $launch_link_request)
    {
        $returnType = '\RusticiSoftware\Cloud\V2\Model\LaunchLinkSchema';
        $request = $this->buildCoursePreviewLaunchLinkWithVersionRequest($course_id, $version_id, $launch_link_request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Cloud\V2\Model\LaunchLinkSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Cloud\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Cloud\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation buildCoursePreviewLaunchLinkWithVersionAsync
     *
     * Get a launch link to preview a Course Version
     *
     * @param  string $course_id (required)
     * @param  int $version_id (required)
     * @param  \RusticiSoftware\Cloud\V2\Model\LaunchLinkRequestSchema $launch_link_request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function buildCoursePreviewLaunchLinkWithVersionAsync($course_id, $version_id, $launch_link_request)
    {
        return $this->buildCoursePreviewLaunchLinkWithVersionAsyncWithHttpInfo($course_id, $version_id, $launch_link_request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation buildCoursePreviewLaunchLinkWithVersionAsyncWithHttpInfo
     *
     * Get a launch link to preview a Course Version
     *
     * @param  string $course_id (required)
     * @param  int $version_id (required)
     * @param  \RusticiSoftware\Cloud\V2\Model\LaunchLinkRequestSchema $launch_link_request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function buildCoursePreviewLaunchLinkWithVersionAsyncWithHttpInfo($course_id, $version_id, $launch_link_request)
    {
        $returnType = '\RusticiSoftware\Cloud\V2\Model\LaunchLinkSchema';
        $request = $this->buildCoursePreviewLaunchLinkWithVersionRequest($course_id, $version_id, $launch_link_request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'buildCoursePreviewLaunchLinkWithVersion'
     *
     * @param  string $course_id (required)
     * @param  int $version_id (required)
     * @param  \RusticiSoftware\Cloud\V2\Model\LaunchLinkRequestSchema $launch_link_request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function buildCoursePreviewLaunchLinkWithVersionRequest($course_id, $version_id, $launch_link_request)
    {
        // verify the required parameter 'course_id' is set
        if ($course_id === null || (is_array($course_id) && count($course_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $course_id when calling buildCoursePreviewLaunchLinkWithVersion'
            );
        }
        // verify the required parameter 'version_id' is set
        if ($version_id === null || (is_array($version_id) && count($version_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version_id when calling buildCoursePreviewLaunchLinkWithVersion'
            );
        }
        // verify the required parameter 'launch_link_request' is set
        if ($launch_link_request === null || (is_array($launch_link_request) && count($launch_link_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $launch_link_request when calling buildCoursePreviewLaunchLinkWithVersion'
            );
        }

        $resourcePath = '/courses/{courseId}/versions/{versionId}/preview';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($course_id !== null) {
            $resourcePath = str_replace(
                '{' . 'courseId' . '}',
                ObjectSerializer::toPathValue($course_id),
                $resourcePath
            );
        }
        // path params
        if ($version_id !== null) {
            $resourcePath = str_replace(
                '{' . 'versionId' . '}',
                ObjectSerializer::toPathValue($version_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($launch_link_request)) {
            $_tempBody = $launch_link_request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;

            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createFetchAndImportCourseJob
     *
     * Create a Course from a package fetched from an external source
     *
     * @param  string $course_id A unique identifier your application will use to identify the course after import. Your application is responsible both for generating this unique ID and for keeping track of the ID for later use. (required)
     * @param  \RusticiSoftware\Cloud\V2\Model\ImportFetchRequestSchema $import_request import_request (required)
     * @param  bool $may_create_new_version Is it OK to create a new version of this course? If this is set to false and the course already exists, the upload will fail. If true and the course already exists then a new version will be created. No effect if the course doesn&#39;t already exist. (optional, default to false)
     * @param  string $postback_url An optional parameter that specifies a URL to send a postback to when the course has finished uploading. (optional)
     *
     * @throws \RusticiSoftware\Cloud\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \RusticiSoftware\Cloud\V2\Model\StringResultSchema
     */
    public function createFetchAndImportCourseJob($course_id, $import_request, $may_create_new_version = 'false', $postback_url = null)
    {
        list($response) = $this->createFetchAndImportCourseJobWithHttpInfo($course_id, $import_request, $may_create_new_version, $postback_url);
        return $response;
    }

    /**
     * Operation createFetchAndImportCourseJobWithHttpInfo
     *
     * Create a Course from a package fetched from an external source
     *
     * @param  string $course_id A unique identifier your application will use to identify the course after import. Your application is responsible both for generating this unique ID and for keeping track of the ID for later use. (required)
     * @param  \RusticiSoftware\Cloud\V2\Model\ImportFetchRequestSchema $import_request (required)
     * @param  bool $may_create_new_version Is it OK to create a new version of this course? If this is set to false and the course already exists, the upload will fail. If true and the course already exists then a new version will be created. No effect if the course doesn&#39;t already exist. (optional, default to false)
     * @param  string $postback_url An optional parameter that specifies a URL to send a postback to when the course has finished uploading. (optional)
     *
     * @throws \RusticiSoftware\Cloud\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \RusticiSoftware\Cloud\V2\Model\StringResultSchema, HTTP status code, HTTP response headers (array of strings)
     */
    public function createFetchAndImportCourseJobWithHttpInfo($course_id, $import_request, $may_create_new_version = 'false', $postback_url = null)
    {
        $returnType = '\RusticiSoftware\Cloud\V2\Model\StringResultSchema';
        $request = $this->createFetchAndImportCourseJobRequest($course_id, $import_request, $may_create_new_version, $postback_url);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Cloud\V2\Model\StringResultSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Cloud\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 409:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Cloud\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createFetchAndImportCourseJobAsync
     *
     * Create a Course from a package fetched from an external source
     *
     * @param  string $course_id A unique identifier your application will use to identify the course after import. Your application is responsible both for generating this unique ID and for keeping track of the ID for later use. (required)
     * @param  \RusticiSoftware\Cloud\V2\Model\ImportFetchRequestSchema $import_request (required)
     * @param  bool $may_create_new_version Is it OK to create a new version of this course? If this is set to false and the course already exists, the upload will fail. If true and the course already exists then a new version will be created. No effect if the course doesn&#39;t already exist. (optional, default to false)
     * @param  string $postback_url An optional parameter that specifies a URL to send a postback to when the course has finished uploading. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createFetchAndImportCourseJobAsync($course_id, $import_request, $may_create_new_version = 'false', $postback_url = null)
    {
        return $this->createFetchAndImportCourseJobAsyncWithHttpInfo($course_id, $import_request, $may_create_new_version, $postback_url)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createFetchAndImportCourseJobAsyncWithHttpInfo
     *
     * Create a Course from a package fetched from an external source
     *
     * @param  string $course_id A unique identifier your application will use to identify the course after import. Your application is responsible both for generating this unique ID and for keeping track of the ID for later use. (required)
     * @param  \RusticiSoftware\Cloud\V2\Model\ImportFetchRequestSchema $import_request (required)
     * @param  bool $may_create_new_version Is it OK to create a new version of this course? If this is set to false and the course already exists, the upload will fail. If true and the course already exists then a new version will be created. No effect if the course doesn&#39;t already exist. (optional, default to false)
     * @param  string $postback_url An optional parameter that specifies a URL to send a postback to when the course has finished uploading. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createFetchAndImportCourseJobAsyncWithHttpInfo($course_id, $import_request, $may_create_new_version = 'false', $postback_url = null)
    {
        $returnType = '\RusticiSoftware\Cloud\V2\Model\StringResultSchema';
        $request = $this->createFetchAndImportCourseJobRequest($course_id, $import_request, $may_create_new_version, $postback_url);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createFetchAndImportCourseJob'
     *
     * @param  string $course_id A unique identifier your application will use to identify the course after import. Your application is responsible both for generating this unique ID and for keeping track of the ID for later use. (required)
     * @param  \RusticiSoftware\Cloud\V2\Model\ImportFetchRequestSchema $import_request (required)
     * @param  bool $may_create_new_version Is it OK to create a new version of this course? If this is set to false and the course already exists, the upload will fail. If true and the course already exists then a new version will be created. No effect if the course doesn&#39;t already exist. (optional, default to false)
     * @param  string $postback_url An optional parameter that specifies a URL to send a postback to when the course has finished uploading. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createFetchAndImportCourseJobRequest($course_id, $import_request, $may_create_new_version = 'false', $postback_url = null)
    {
        // verify the required parameter 'course_id' is set
        if ($course_id === null || (is_array($course_id) && count($course_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $course_id when calling createFetchAndImportCourseJob'
            );
        }
        // verify the required parameter 'import_request' is set
        if ($import_request === null || (is_array($import_request) && count($import_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $import_request when calling createFetchAndImportCourseJob'
            );
        }

        $resourcePath = '/courses/importJobs';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($course_id !== null) {
            $queryParams['courseId'] = ObjectSerializer::toQueryValue($course_id);
        }
        // query params
        if ($may_create_new_version !== null) {
            $queryParams['mayCreateNewVersion'] = ObjectSerializer::toQueryValue($may_create_new_version);
        }
        // query params
        if ($postback_url !== null) {
            $queryParams['postbackUrl'] = ObjectSerializer::toQueryValue($postback_url);
        }


        // body params
        $_tempBody = null;
        if (isset($import_request)) {
            $_tempBody = $import_request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;

            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createNoUploadAndImportCourseJob
     *
     * Create a Course from a fetched or referenced external media file
     *
     * @param  string $course_id A unique identifier your application will use to identify the course after import. Your application is responsible both for generating this unique ID and for keeping track of the ID for later use. (required)
     * @param  \RusticiSoftware\Cloud\V2\Model\ImportRequestSchema $import_request import_request (required)
     * @param  bool $may_create_new_version Is it OK to create a new version of this course? If this is set to false and the course already exists, the upload will fail. If true and the course already exists then a new version will be created. No effect if the course doesn&#39;t already exist. (optional, default to false)
     * @param  string $postback_url An optional parameter that specifies a URL to send a postback to when the course has finished uploading. (optional)
     *
     * @throws \RusticiSoftware\Cloud\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \RusticiSoftware\Cloud\V2\Model\StringResultSchema
     */
    public function createNoUploadAndImportCourseJob($course_id, $import_request, $may_create_new_version = 'false', $postback_url = null)
    {
        list($response) = $this->createNoUploadAndImportCourseJobWithHttpInfo($course_id, $import_request, $may_create_new_version, $postback_url);
        return $response;
    }

    /**
     * Operation createNoUploadAndImportCourseJobWithHttpInfo
     *
     * Create a Course from a fetched or referenced external media file
     *
     * @param  string $course_id A unique identifier your application will use to identify the course after import. Your application is responsible both for generating this unique ID and for keeping track of the ID for later use. (required)
     * @param  \RusticiSoftware\Cloud\V2\Model\ImportRequestSchema $import_request (required)
     * @param  bool $may_create_new_version Is it OK to create a new version of this course? If this is set to false and the course already exists, the upload will fail. If true and the course already exists then a new version will be created. No effect if the course doesn&#39;t already exist. (optional, default to false)
     * @param  string $postback_url An optional parameter that specifies a URL to send a postback to when the course has finished uploading. (optional)
     *
     * @throws \RusticiSoftware\Cloud\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \RusticiSoftware\Cloud\V2\Model\StringResultSchema, HTTP status code, HTTP response headers (array of strings)
     */
    public function createNoUploadAndImportCourseJobWithHttpInfo($course_id, $import_request, $may_create_new_version = 'false', $postback_url = null)
    {
        $returnType = '\RusticiSoftware\Cloud\V2\Model\StringResultSchema';
        $request = $this->createNoUploadAndImportCourseJobRequest($course_id, $import_request, $may_create_new_version, $postback_url);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Cloud\V2\Model\StringResultSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Cloud\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 409:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Cloud\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createNoUploadAndImportCourseJobAsync
     *
     * Create a Course from a fetched or referenced external media file
     *
     * @param  string $course_id A unique identifier your application will use to identify the course after import. Your application is responsible both for generating this unique ID and for keeping track of the ID for later use. (required)
     * @param  \RusticiSoftware\Cloud\V2\Model\ImportRequestSchema $import_request (required)
     * @param  bool $may_create_new_version Is it OK to create a new version of this course? If this is set to false and the course already exists, the upload will fail. If true and the course already exists then a new version will be created. No effect if the course doesn&#39;t already exist. (optional, default to false)
     * @param  string $postback_url An optional parameter that specifies a URL to send a postback to when the course has finished uploading. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createNoUploadAndImportCourseJobAsync($course_id, $import_request, $may_create_new_version = 'false', $postback_url = null)
    {
        return $this->createNoUploadAndImportCourseJobAsyncWithHttpInfo($course_id, $import_request, $may_create_new_version, $postback_url)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createNoUploadAndImportCourseJobAsyncWithHttpInfo
     *
     * Create a Course from a fetched or referenced external media file
     *
     * @param  string $course_id A unique identifier your application will use to identify the course after import. Your application is responsible both for generating this unique ID and for keeping track of the ID for later use. (required)
     * @param  \RusticiSoftware\Cloud\V2\Model\ImportRequestSchema $import_request (required)
     * @param  bool $may_create_new_version Is it OK to create a new version of this course? If this is set to false and the course already exists, the upload will fail. If true and the course already exists then a new version will be created. No effect if the course doesn&#39;t already exist. (optional, default to false)
     * @param  string $postback_url An optional parameter that specifies a URL to send a postback to when the course has finished uploading. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createNoUploadAndImportCourseJobAsyncWithHttpInfo($course_id, $import_request, $may_create_new_version = 'false', $postback_url = null)
    {
        $returnType = '\RusticiSoftware\Cloud\V2\Model\StringResultSchema';
        $request = $this->createNoUploadAndImportCourseJobRequest($course_id, $import_request, $may_create_new_version, $postback_url);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createNoUploadAndImportCourseJob'
     *
     * @param  string $course_id A unique identifier your application will use to identify the course after import. Your application is responsible both for generating this unique ID and for keeping track of the ID for later use. (required)
     * @param  \RusticiSoftware\Cloud\V2\Model\ImportRequestSchema $import_request (required)
     * @param  bool $may_create_new_version Is it OK to create a new version of this course? If this is set to false and the course already exists, the upload will fail. If true and the course already exists then a new version will be created. No effect if the course doesn&#39;t already exist. (optional, default to false)
     * @param  string $postback_url An optional parameter that specifies a URL to send a postback to when the course has finished uploading. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createNoUploadAndImportCourseJobRequest($course_id, $import_request, $may_create_new_version = 'false', $postback_url = null)
    {
        // verify the required parameter 'course_id' is set
        if ($course_id === null || (is_array($course_id) && count($course_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $course_id when calling createNoUploadAndImportCourseJob'
            );
        }
        // verify the required parameter 'import_request' is set
        if ($import_request === null || (is_array($import_request) && count($import_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $import_request when calling createNoUploadAndImportCourseJob'
            );
        }

        $resourcePath = '/courses/importJobs/noUpload';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($course_id !== null) {
            $queryParams['courseId'] = ObjectSerializer::toQueryValue($course_id);
        }
        // query params
        if ($may_create_new_version !== null) {
            $queryParams['mayCreateNewVersion'] = ObjectSerializer::toQueryValue($may_create_new_version);
        }
        // query params
        if ($postback_url !== null) {
            $queryParams['postbackUrl'] = ObjectSerializer::toQueryValue($postback_url);
        }


        // body params
        $_tempBody = null;
        if (isset($import_request)) {
            $_tempBody = $import_request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;

            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createUploadAndImportCourseJob
     *
     * Create a Course from an uploaded package
     *
     * @param  string $course_id A unique identifier your application will use to identify the course after import. Your application is responsible both for generating this unique ID and for keeping track of the ID for later use. (required)
     * @param  bool $may_create_new_version Is it OK to create a new version of this course? If this is set to false and the course already exists, the upload will fail. If true and the course already exists then a new version will be created. No effect if the course doesn&#39;t already exist. (optional, default to false)
     * @param  string $postback_url An optional parameter that specifies a URL to send a postback to when the course has finished uploading. (optional)
     * @param  string $uploaded_content_type The MIME type identifier for the content to be uploaded. This is required if uploading a media file (.pdf, .mp3, or .mp4). (optional, default to application/zip)
     * @param  string $content_metadata Serialized &#39;mediaFileMetadata&#39; schema. (optional)
     * @param  \SplFileObject $file The zip file of the course contents to import. (optional)
     *
     * @throws \RusticiSoftware\Cloud\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \RusticiSoftware\Cloud\V2\Model\StringResultSchema
     */
    public function createUploadAndImportCourseJob($course_id, $may_create_new_version = 'false', $postback_url = null, $uploaded_content_type = 'application/zip', $content_metadata = null, $file = null)
    {
        list($response) = $this->createUploadAndImportCourseJobWithHttpInfo($course_id, $may_create_new_version, $postback_url, $uploaded_content_type, $content_metadata, $file);
        return $response;
    }

    /**
     * Operation createUploadAndImportCourseJobWithHttpInfo
     *
     * Create a Course from an uploaded package
     *
     * @param  string $course_id A unique identifier your application will use to identify the course after import. Your application is responsible both for generating this unique ID and for keeping track of the ID for later use. (required)
     * @param  bool $may_create_new_version Is it OK to create a new version of this course? If this is set to false and the course already exists, the upload will fail. If true and the course already exists then a new version will be created. No effect if the course doesn&#39;t already exist. (optional, default to false)
     * @param  string $postback_url An optional parameter that specifies a URL to send a postback to when the course has finished uploading. (optional)
     * @param  string $uploaded_content_type The MIME type identifier for the content to be uploaded. This is required if uploading a media file (.pdf, .mp3, or .mp4). (optional, default to application/zip)
     * @param  string $content_metadata Serialized &#39;mediaFileMetadata&#39; schema. (optional)
     * @param  \SplFileObject $file The zip file of the course contents to import. (optional)
     *
     * @throws \RusticiSoftware\Cloud\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \RusticiSoftware\Cloud\V2\Model\StringResultSchema, HTTP status code, HTTP response headers (array of strings)
     */
    public function createUploadAndImportCourseJobWithHttpInfo($course_id, $may_create_new_version = 'false', $postback_url = null, $uploaded_content_type = 'application/zip', $content_metadata = null, $file = null)
    {
        $returnType = '\RusticiSoftware\Cloud\V2\Model\StringResultSchema';
        $request = $this->createUploadAndImportCourseJobRequest($course_id, $may_create_new_version, $postback_url, $uploaded_content_type, $content_metadata, $file);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Cloud\V2\Model\StringResultSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Cloud\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 409:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Cloud\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createUploadAndImportCourseJobAsync
     *
     * Create a Course from an uploaded package
     *
     * @param  string $course_id A unique identifier your application will use to identify the course after import. Your application is responsible both for generating this unique ID and for keeping track of the ID for later use. (required)
     * @param  bool $may_create_new_version Is it OK to create a new version of this course? If this is set to false and the course already exists, the upload will fail. If true and the course already exists then a new version will be created. No effect if the course doesn&#39;t already exist. (optional, default to false)
     * @param  string $postback_url An optional parameter that specifies a URL to send a postback to when the course has finished uploading. (optional)
     * @param  string $uploaded_content_type The MIME type identifier for the content to be uploaded. This is required if uploading a media file (.pdf, .mp3, or .mp4). (optional, default to application/zip)
     * @param  string $content_metadata Serialized &#39;mediaFileMetadata&#39; schema. (optional)
     * @param  \SplFileObject $file The zip file of the course contents to import. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createUploadAndImportCourseJobAsync($course_id, $may_create_new_version = 'false', $postback_url = null, $uploaded_content_type = 'application/zip', $content_metadata = null, $file = null)
    {
        return $this->createUploadAndImportCourseJobAsyncWithHttpInfo($course_id, $may_create_new_version, $postback_url, $uploaded_content_type, $content_metadata, $file)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createUploadAndImportCourseJobAsyncWithHttpInfo
     *
     * Create a Course from an uploaded package
     *
     * @param  string $course_id A unique identifier your application will use to identify the course after import. Your application is responsible both for generating this unique ID and for keeping track of the ID for later use. (required)
     * @param  bool $may_create_new_version Is it OK to create a new version of this course? If this is set to false and the course already exists, the upload will fail. If true and the course already exists then a new version will be created. No effect if the course doesn&#39;t already exist. (optional, default to false)
     * @param  string $postback_url An optional parameter that specifies a URL to send a postback to when the course has finished uploading. (optional)
     * @param  string $uploaded_content_type The MIME type identifier for the content to be uploaded. This is required if uploading a media file (.pdf, .mp3, or .mp4). (optional, default to application/zip)
     * @param  string $content_metadata Serialized &#39;mediaFileMetadata&#39; schema. (optional)
     * @param  \SplFileObject $file The zip file of the course contents to import. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createUploadAndImportCourseJobAsyncWithHttpInfo($course_id, $may_create_new_version = 'false', $postback_url = null, $uploaded_content_type = 'application/zip', $content_metadata = null, $file = null)
    {
        $returnType = '\RusticiSoftware\Cloud\V2\Model\StringResultSchema';
        $request = $this->createUploadAndImportCourseJobRequest($course_id, $may_create_new_version, $postback_url, $uploaded_content_type, $content_metadata, $file);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createUploadAndImportCourseJob'
     *
     * @param  string $course_id A unique identifier your application will use to identify the course after import. Your application is responsible both for generating this unique ID and for keeping track of the ID for later use. (required)
     * @param  bool $may_create_new_version Is it OK to create a new version of this course? If this is set to false and the course already exists, the upload will fail. If true and the course already exists then a new version will be created. No effect if the course doesn&#39;t already exist. (optional, default to false)
     * @param  string $postback_url An optional parameter that specifies a URL to send a postback to when the course has finished uploading. (optional)
     * @param  string $uploaded_content_type The MIME type identifier for the content to be uploaded. This is required if uploading a media file (.pdf, .mp3, or .mp4). (optional, default to application/zip)
     * @param  string $content_metadata Serialized &#39;mediaFileMetadata&#39; schema. (optional)
     * @param  \SplFileObject $file The zip file of the course contents to import. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createUploadAndImportCourseJobRequest($course_id, $may_create_new_version = 'false', $postback_url = null, $uploaded_content_type = 'application/zip', $content_metadata = null, $file = null)
    {
        // verify the required parameter 'course_id' is set
        if ($course_id === null || (is_array($course_id) && count($course_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $course_id when calling createUploadAndImportCourseJob'
            );
        }

        $resourcePath = '/courses/importJobs/upload';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($course_id !== null) {
            $queryParams['courseId'] = ObjectSerializer::toQueryValue($course_id);
        }
        // query params
        if ($may_create_new_version !== null) {
            $queryParams['mayCreateNewVersion'] = ObjectSerializer::toQueryValue($may_create_new_version);
        }
        // query params
        if ($postback_url !== null) {
            $queryParams['postbackUrl'] = ObjectSerializer::toQueryValue($postback_url);
        }
        // header params
        if ($uploaded_content_type !== null) {
            $headerParams['uploadedContentType'] = ObjectSerializer::toHeaderValue($uploaded_content_type);
        }


        // form params
        if ($content_metadata !== null) {
            $formParams['contentMetadata'] = ObjectSerializer::toFormValue($content_metadata);
        }
        // form params
        if ($file !== null) {
            $multipart = true;
            $formParams['file'] = \GuzzleHttp\Psr7\Utils::tryFopen(ObjectSerializer::toFormValue($file), 'rb');
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['multipart/form-data']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;

            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteCourse
     *
     * Delete a Course
     *
     * @param  string $course_id course_id (required)
     *
     * @throws \RusticiSoftware\Cloud\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteCourse($course_id)
    {
        $this->deleteCourseWithHttpInfo($course_id);
    }

    /**
     * Operation deleteCourseWithHttpInfo
     *
     * Delete a Course
     *
     * @param  string $course_id (required)
     *
     * @throws \RusticiSoftware\Cloud\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteCourseWithHttpInfo($course_id)
    {
        $returnType = '';
        $request = $this->deleteCourseRequest($course_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Cloud\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Cloud\V2\Model\ResponseError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteCourseAsync
     *
     * Delete a Course
     *
     * @param  string $course_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteCourseAsync($course_id)
    {
        return $this->deleteCourseAsyncWithHttpInfo($course_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteCourseAsyncWithHttpInfo
     *
     * Delete a Course
     *
     * @param  string $course_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteCourseAsyncWithHttpInfo($course_id)
    {
        $returnType = '';
        $request = $this->deleteCourseRequest($course_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteCourse'
     *
     * @param  string $course_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteCourseRequest($course_id)
    {
        // verify the required parameter 'course_id' is set
        if ($course_id === null || (is_array($course_id) && count($course_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $course_id when calling deleteCourse'
            );
        }

        $resourcePath = '/courses/{courseId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($course_id !== null) {
            $resourcePath = str_replace(
                '{' . 'courseId' . '}',
                ObjectSerializer::toPathValue($course_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;

            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteCourseAsset
     *
     * Delete an asset file from a Course
     *
     * @param  string $course_id course_id (required)
     * @param  string $relative_path Relative path of the asset within the course. (required)
     *
     * @throws \RusticiSoftware\Cloud\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteCourseAsset($course_id, $relative_path)
    {
        $this->deleteCourseAssetWithHttpInfo($course_id, $relative_path);
    }

    /**
     * Operation deleteCourseAssetWithHttpInfo
     *
     * Delete an asset file from a Course
     *
     * @param  string $course_id (required)
     * @param  string $relative_path Relative path of the asset within the course. (required)
     *
     * @throws \RusticiSoftware\Cloud\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteCourseAssetWithHttpInfo($course_id, $relative_path)
    {
        $returnType = '';
        $request = $this->deleteCourseAssetRequest($course_id, $relative_path);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Cloud\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Cloud\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteCourseAssetAsync
     *
     * Delete an asset file from a Course
     *
     * @param  string $course_id (required)
     * @param  string $relative_path Relative path of the asset within the course. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteCourseAssetAsync($course_id, $relative_path)
    {
        return $this->deleteCourseAssetAsyncWithHttpInfo($course_id, $relative_path)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteCourseAssetAsyncWithHttpInfo
     *
     * Delete an asset file from a Course
     *
     * @param  string $course_id (required)
     * @param  string $relative_path Relative path of the asset within the course. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteCourseAssetAsyncWithHttpInfo($course_id, $relative_path)
    {
        $returnType = '';
        $request = $this->deleteCourseAssetRequest($course_id, $relative_path);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteCourseAsset'
     *
     * @param  string $course_id (required)
     * @param  string $relative_path Relative path of the asset within the course. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteCourseAssetRequest($course_id, $relative_path)
    {
        // verify the required parameter 'course_id' is set
        if ($course_id === null || (is_array($course_id) && count($course_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $course_id when calling deleteCourseAsset'
            );
        }
        // verify the required parameter 'relative_path' is set
        if ($relative_path === null || (is_array($relative_path) && count($relative_path) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $relative_path when calling deleteCourseAsset'
            );
        }

        $resourcePath = '/courses/{courseId}/asset';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($relative_path !== null) {
            $queryParams['relativePath'] = ObjectSerializer::toQueryValue($relative_path);
        }

        // path params
        if ($course_id !== null) {
            $resourcePath = str_replace(
                '{' . 'courseId' . '}',
                ObjectSerializer::toPathValue($course_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;

            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteCourseConfigurationSetting
     *
     * Delete a configuration setting explicitly set for a Course
     *
     * @param  string $course_id course_id (required)
     * @param  string $setting_id setting_id (required)
     *
     * @throws \RusticiSoftware\Cloud\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteCourseConfigurationSetting($course_id, $setting_id)
    {
        $this->deleteCourseConfigurationSettingWithHttpInfo($course_id, $setting_id);
    }

    /**
     * Operation deleteCourseConfigurationSettingWithHttpInfo
     *
     * Delete a configuration setting explicitly set for a Course
     *
     * @param  string $course_id (required)
     * @param  string $setting_id (required)
     *
     * @throws \RusticiSoftware\Cloud\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteCourseConfigurationSettingWithHttpInfo($course_id, $setting_id)
    {
        $returnType = '';
        $request = $this->deleteCourseConfigurationSettingRequest($course_id, $setting_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Cloud\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Cloud\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteCourseConfigurationSettingAsync
     *
     * Delete a configuration setting explicitly set for a Course
     *
     * @param  string $course_id (required)
     * @param  string $setting_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteCourseConfigurationSettingAsync($course_id, $setting_id)
    {
        return $this->deleteCourseConfigurationSettingAsyncWithHttpInfo($course_id, $setting_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteCourseConfigurationSettingAsyncWithHttpInfo
     *
     * Delete a configuration setting explicitly set for a Course
     *
     * @param  string $course_id (required)
     * @param  string $setting_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteCourseConfigurationSettingAsyncWithHttpInfo($course_id, $setting_id)
    {
        $returnType = '';
        $request = $this->deleteCourseConfigurationSettingRequest($course_id, $setting_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteCourseConfigurationSetting'
     *
     * @param  string $course_id (required)
     * @param  string $setting_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteCourseConfigurationSettingRequest($course_id, $setting_id)
    {
        // verify the required parameter 'course_id' is set
        if ($course_id === null || (is_array($course_id) && count($course_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $course_id when calling deleteCourseConfigurationSetting'
            );
        }
        // verify the required parameter 'setting_id' is set
        if ($setting_id === null || (is_array($setting_id) && count($setting_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $setting_id when calling deleteCourseConfigurationSetting'
            );
        }

        $resourcePath = '/courses/{courseId}/configuration/{settingId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($course_id !== null) {
            $resourcePath = str_replace(
                '{' . 'courseId' . '}',
                ObjectSerializer::toPathValue($course_id),
                $resourcePath
            );
        }
        // path params
        if ($setting_id !== null) {
            $resourcePath = str_replace(
                '{' . 'settingId' . '}',
                ObjectSerializer::toPathValue($setting_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;

            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteCourseTags
     *
     * Delete tags from a Course
     *
     * @param  string $course_id course_id (required)
     * @param  \RusticiSoftware\Cloud\V2\Model\TagListSchema $tags tags (required)
     *
     * @throws \RusticiSoftware\Cloud\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteCourseTags($course_id, $tags)
    {
        $this->deleteCourseTagsWithHttpInfo($course_id, $tags);
    }

    /**
     * Operation deleteCourseTagsWithHttpInfo
     *
     * Delete tags from a Course
     *
     * @param  string $course_id (required)
     * @param  \RusticiSoftware\Cloud\V2\Model\TagListSchema $tags (required)
     *
     * @throws \RusticiSoftware\Cloud\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteCourseTagsWithHttpInfo($course_id, $tags)
    {
        $returnType = '';
        $request = $this->deleteCourseTagsRequest($course_id, $tags);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Cloud\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Cloud\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteCourseTagsAsync
     *
     * Delete tags from a Course
     *
     * @param  string $course_id (required)
     * @param  \RusticiSoftware\Cloud\V2\Model\TagListSchema $tags (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteCourseTagsAsync($course_id, $tags)
    {
        return $this->deleteCourseTagsAsyncWithHttpInfo($course_id, $tags)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteCourseTagsAsyncWithHttpInfo
     *
     * Delete tags from a Course
     *
     * @param  string $course_id (required)
     * @param  \RusticiSoftware\Cloud\V2\Model\TagListSchema $tags (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteCourseTagsAsyncWithHttpInfo($course_id, $tags)
    {
        $returnType = '';
        $request = $this->deleteCourseTagsRequest($course_id, $tags);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteCourseTags'
     *
     * @param  string $course_id (required)
     * @param  \RusticiSoftware\Cloud\V2\Model\TagListSchema $tags (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteCourseTagsRequest($course_id, $tags)
    {
        // verify the required parameter 'course_id' is set
        if ($course_id === null || (is_array($course_id) && count($course_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $course_id when calling deleteCourseTags'
            );
        }
        // verify the required parameter 'tags' is set
        if ($tags === null || (is_array($tags) && count($tags) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $tags when calling deleteCourseTags'
            );
        }

        $resourcePath = '/courses/{courseId}/tags';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($course_id !== null) {
            $resourcePath = str_replace(
                '{' . 'courseId' . '}',
                ObjectSerializer::toPathValue($course_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($tags)) {
            $_tempBody = $tags;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;

            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteCourseVersion
     *
     * Delete a Course Version
     *
     * @param  string $course_id course_id (required)
     * @param  int $version_id version_id (required)
     *
     * @throws \RusticiSoftware\Cloud\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteCourseVersion($course_id, $version_id)
    {
        $this->deleteCourseVersionWithHttpInfo($course_id, $version_id);
    }

    /**
     * Operation deleteCourseVersionWithHttpInfo
     *
     * Delete a Course Version
     *
     * @param  string $course_id (required)
     * @param  int $version_id (required)
     *
     * @throws \RusticiSoftware\Cloud\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteCourseVersionWithHttpInfo($course_id, $version_id)
    {
        $returnType = '';
        $request = $this->deleteCourseVersionRequest($course_id, $version_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Cloud\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Cloud\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteCourseVersionAsync
     *
     * Delete a Course Version
     *
     * @param  string $course_id (required)
     * @param  int $version_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteCourseVersionAsync($course_id, $version_id)
    {
        return $this->deleteCourseVersionAsyncWithHttpInfo($course_id, $version_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteCourseVersionAsyncWithHttpInfo
     *
     * Delete a Course Version
     *
     * @param  string $course_id (required)
     * @param  int $version_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteCourseVersionAsyncWithHttpInfo($course_id, $version_id)
    {
        $returnType = '';
        $request = $this->deleteCourseVersionRequest($course_id, $version_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteCourseVersion'
     *
     * @param  string $course_id (required)
     * @param  int $version_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteCourseVersionRequest($course_id, $version_id)
    {
        // verify the required parameter 'course_id' is set
        if ($course_id === null || (is_array($course_id) && count($course_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $course_id when calling deleteCourseVersion'
            );
        }
        // verify the required parameter 'version_id' is set
        if ($version_id === null || (is_array($version_id) && count($version_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version_id when calling deleteCourseVersion'
            );
        }

        $resourcePath = '/courses/{courseId}/versions/{versionId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($course_id !== null) {
            $resourcePath = str_replace(
                '{' . 'courseId' . '}',
                ObjectSerializer::toPathValue($course_id),
                $resourcePath
            );
        }
        // path params
        if ($version_id !== null) {
            $resourcePath = str_replace(
                '{' . 'versionId' . '}',
                ObjectSerializer::toPathValue($version_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;

            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteCourseVersionAsset
     *
     * Delete an asset file from a Course Version
     *
     * @param  string $course_id course_id (required)
     * @param  int $version_id version_id (required)
     * @param  string $relative_path Relative path of the asset within the course. (required)
     *
     * @throws \RusticiSoftware\Cloud\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteCourseVersionAsset($course_id, $version_id, $relative_path)
    {
        $this->deleteCourseVersionAssetWithHttpInfo($course_id, $version_id, $relative_path);
    }

    /**
     * Operation deleteCourseVersionAssetWithHttpInfo
     *
     * Delete an asset file from a Course Version
     *
     * @param  string $course_id (required)
     * @param  int $version_id (required)
     * @param  string $relative_path Relative path of the asset within the course. (required)
     *
     * @throws \RusticiSoftware\Cloud\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteCourseVersionAssetWithHttpInfo($course_id, $version_id, $relative_path)
    {
        $returnType = '';
        $request = $this->deleteCourseVersionAssetRequest($course_id, $version_id, $relative_path);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Cloud\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Cloud\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteCourseVersionAssetAsync
     *
     * Delete an asset file from a Course Version
     *
     * @param  string $course_id (required)
     * @param  int $version_id (required)
     * @param  string $relative_path Relative path of the asset within the course. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteCourseVersionAssetAsync($course_id, $version_id, $relative_path)
    {
        return $this->deleteCourseVersionAssetAsyncWithHttpInfo($course_id, $version_id, $relative_path)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteCourseVersionAssetAsyncWithHttpInfo
     *
     * Delete an asset file from a Course Version
     *
     * @param  string $course_id (required)
     * @param  int $version_id (required)
     * @param  string $relative_path Relative path of the asset within the course. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteCourseVersionAssetAsyncWithHttpInfo($course_id, $version_id, $relative_path)
    {
        $returnType = '';
        $request = $this->deleteCourseVersionAssetRequest($course_id, $version_id, $relative_path);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteCourseVersionAsset'
     *
     * @param  string $course_id (required)
     * @param  int $version_id (required)
     * @param  string $relative_path Relative path of the asset within the course. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteCourseVersionAssetRequest($course_id, $version_id, $relative_path)
    {
        // verify the required parameter 'course_id' is set
        if ($course_id === null || (is_array($course_id) && count($course_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $course_id when calling deleteCourseVersionAsset'
            );
        }
        // verify the required parameter 'version_id' is set
        if ($version_id === null || (is_array($version_id) && count($version_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version_id when calling deleteCourseVersionAsset'
            );
        }
        // verify the required parameter 'relative_path' is set
        if ($relative_path === null || (is_array($relative_path) && count($relative_path) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $relative_path when calling deleteCourseVersionAsset'
            );
        }

        $resourcePath = '/courses/{courseId}/versions/{versionId}/asset';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($relative_path !== null) {
            $queryParams['relativePath'] = ObjectSerializer::toQueryValue($relative_path);
        }

        // path params
        if ($course_id !== null) {
            $resourcePath = str_replace(
                '{' . 'courseId' . '}',
                ObjectSerializer::toPathValue($course_id),
                $resourcePath
            );
        }
        // path params
        if ($version_id !== null) {
            $resourcePath = str_replace(
                '{' . 'versionId' . '}',
                ObjectSerializer::toPathValue($version_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;

            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteCourseVersionConfigurationSetting
     *
     * Delete a configuration setting explicitly set for a Course Version
     *
     * @param  string $course_id course_id (required)
     * @param  int $version_id version_id (required)
     * @param  string $setting_id setting_id (required)
     *
     * @throws \RusticiSoftware\Cloud\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteCourseVersionConfigurationSetting($course_id, $version_id, $setting_id)
    {
        $this->deleteCourseVersionConfigurationSettingWithHttpInfo($course_id, $version_id, $setting_id);
    }

    /**
     * Operation deleteCourseVersionConfigurationSettingWithHttpInfo
     *
     * Delete a configuration setting explicitly set for a Course Version
     *
     * @param  string $course_id (required)
     * @param  int $version_id (required)
     * @param  string $setting_id (required)
     *
     * @throws \RusticiSoftware\Cloud\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteCourseVersionConfigurationSettingWithHttpInfo($course_id, $version_id, $setting_id)
    {
        $returnType = '';
        $request = $this->deleteCourseVersionConfigurationSettingRequest($course_id, $version_id, $setting_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Cloud\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Cloud\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteCourseVersionConfigurationSettingAsync
     *
     * Delete a configuration setting explicitly set for a Course Version
     *
     * @param  string $course_id (required)
     * @param  int $version_id (required)
     * @param  string $setting_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteCourseVersionConfigurationSettingAsync($course_id, $version_id, $setting_id)
    {
        return $this->deleteCourseVersionConfigurationSettingAsyncWithHttpInfo($course_id, $version_id, $setting_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteCourseVersionConfigurationSettingAsyncWithHttpInfo
     *
     * Delete a configuration setting explicitly set for a Course Version
     *
     * @param  string $course_id (required)
     * @param  int $version_id (required)
     * @param  string $setting_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteCourseVersionConfigurationSettingAsyncWithHttpInfo($course_id, $version_id, $setting_id)
    {
        $returnType = '';
        $request = $this->deleteCourseVersionConfigurationSettingRequest($course_id, $version_id, $setting_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteCourseVersionConfigurationSetting'
     *
     * @param  string $course_id (required)
     * @param  int $version_id (required)
     * @param  string $setting_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteCourseVersionConfigurationSettingRequest($course_id, $version_id, $setting_id)
    {
        // verify the required parameter 'course_id' is set
        if ($course_id === null || (is_array($course_id) && count($course_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $course_id when calling deleteCourseVersionConfigurationSetting'
            );
        }
        // verify the required parameter 'version_id' is set
        if ($version_id === null || (is_array($version_id) && count($version_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version_id when calling deleteCourseVersionConfigurationSetting'
            );
        }
        // verify the required parameter 'setting_id' is set
        if ($setting_id === null || (is_array($setting_id) && count($setting_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $setting_id when calling deleteCourseVersionConfigurationSetting'
            );
        }

        $resourcePath = '/courses/{courseId}/versions/{versionId}/configuration/{settingId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($course_id !== null) {
            $resourcePath = str_replace(
                '{' . 'courseId' . '}',
                ObjectSerializer::toPathValue($course_id),
                $resourcePath
            );
        }
        // path params
        if ($version_id !== null) {
            $resourcePath = str_replace(
                '{' . 'versionId' . '}',
                ObjectSerializer::toPathValue($version_id),
                $resourcePath
            );
        }
        // path params
        if ($setting_id !== null) {
            $resourcePath = str_replace(
                '{' . 'settingId' . '}',
                ObjectSerializer::toPathValue($setting_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;

            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCourse
     *
     * Get detailed information about a Course
     *
     * @param  string $course_id course_id (required)
     * @param  bool $include_registration_count Include the registration count in the results (optional, default to false)
     * @param  bool $include_course_metadata Include course metadata in the results. If the course has no metadata, adding this parameter has no effect. (optional, default to false)
     *
     * @throws \RusticiSoftware\Cloud\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \RusticiSoftware\Cloud\V2\Model\CourseSchema
     */
    public function getCourse($course_id, $include_registration_count = 'false', $include_course_metadata = 'false')
    {
        list($response) = $this->getCourseWithHttpInfo($course_id, $include_registration_count, $include_course_metadata);
        return $response;
    }

    /**
     * Operation getCourseWithHttpInfo
     *
     * Get detailed information about a Course
     *
     * @param  string $course_id (required)
     * @param  bool $include_registration_count Include the registration count in the results (optional, default to false)
     * @param  bool $include_course_metadata Include course metadata in the results. If the course has no metadata, adding this parameter has no effect. (optional, default to false)
     *
     * @throws \RusticiSoftware\Cloud\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \RusticiSoftware\Cloud\V2\Model\CourseSchema, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCourseWithHttpInfo($course_id, $include_registration_count = 'false', $include_course_metadata = 'false')
    {
        $returnType = '\RusticiSoftware\Cloud\V2\Model\CourseSchema';
        $request = $this->getCourseRequest($course_id, $include_registration_count, $include_course_metadata);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Cloud\V2\Model\CourseSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Cloud\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Cloud\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getCourseAsync
     *
     * Get detailed information about a Course
     *
     * @param  string $course_id (required)
     * @param  bool $include_registration_count Include the registration count in the results (optional, default to false)
     * @param  bool $include_course_metadata Include course metadata in the results. If the course has no metadata, adding this parameter has no effect. (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCourseAsync($course_id, $include_registration_count = 'false', $include_course_metadata = 'false')
    {
        return $this->getCourseAsyncWithHttpInfo($course_id, $include_registration_count, $include_course_metadata)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCourseAsyncWithHttpInfo
     *
     * Get detailed information about a Course
     *
     * @param  string $course_id (required)
     * @param  bool $include_registration_count Include the registration count in the results (optional, default to false)
     * @param  bool $include_course_metadata Include course metadata in the results. If the course has no metadata, adding this parameter has no effect. (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCourseAsyncWithHttpInfo($course_id, $include_registration_count = 'false', $include_course_metadata = 'false')
    {
        $returnType = '\RusticiSoftware\Cloud\V2\Model\CourseSchema';
        $request = $this->getCourseRequest($course_id, $include_registration_count, $include_course_metadata);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCourse'
     *
     * @param  string $course_id (required)
     * @param  bool $include_registration_count Include the registration count in the results (optional, default to false)
     * @param  bool $include_course_metadata Include course metadata in the results. If the course has no metadata, adding this parameter has no effect. (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getCourseRequest($course_id, $include_registration_count = 'false', $include_course_metadata = 'false')
    {
        // verify the required parameter 'course_id' is set
        if ($course_id === null || (is_array($course_id) && count($course_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $course_id when calling getCourse'
            );
        }

        $resourcePath = '/courses/{courseId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($include_registration_count !== null) {
            $queryParams['includeRegistrationCount'] = ObjectSerializer::toQueryValue($include_registration_count);
        }
        // query params
        if ($include_course_metadata !== null) {
            $queryParams['includeCourseMetadata'] = ObjectSerializer::toQueryValue($include_course_metadata);
        }

        // path params
        if ($course_id !== null) {
            $resourcePath = str_replace(
                '{' . 'courseId' . '}',
                ObjectSerializer::toPathValue($course_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;

            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCourseAsset
     *
     * Download an asset file from a Course
     *
     * @param  string $course_id course_id (required)
     * @param  string $relative_path Relative path of the asset within the course. (required)
     *
     * @throws \RusticiSoftware\Cloud\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getCourseAsset($course_id, $relative_path)
    {
        list($response) = $this->getCourseAssetWithHttpInfo($course_id, $relative_path);
        return $response;
    }

    /**
     * Operation getCourseAssetWithHttpInfo
     *
     * Download an asset file from a Course
     *
     * @param  string $course_id (required)
     * @param  string $relative_path Relative path of the asset within the course. (required)
     *
     * @throws \RusticiSoftware\Cloud\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCourseAssetWithHttpInfo($course_id, $relative_path)
    {
        $returnType = '\SplFileObject';
        $request = $this->getCourseAssetRequest($course_id, $relative_path);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Cloud\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Cloud\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getCourseAssetAsync
     *
     * Download an asset file from a Course
     *
     * @param  string $course_id (required)
     * @param  string $relative_path Relative path of the asset within the course. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCourseAssetAsync($course_id, $relative_path)
    {
        return $this->getCourseAssetAsyncWithHttpInfo($course_id, $relative_path)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCourseAssetAsyncWithHttpInfo
     *
     * Download an asset file from a Course
     *
     * @param  string $course_id (required)
     * @param  string $relative_path Relative path of the asset within the course. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCourseAssetAsyncWithHttpInfo($course_id, $relative_path)
    {
        $returnType = '\SplFileObject';
        $request = $this->getCourseAssetRequest($course_id, $relative_path);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCourseAsset'
     *
     * @param  string $course_id (required)
     * @param  string $relative_path Relative path of the asset within the course. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getCourseAssetRequest($course_id, $relative_path)
    {
        // verify the required parameter 'course_id' is set
        if ($course_id === null || (is_array($course_id) && count($course_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $course_id when calling getCourseAsset'
            );
        }
        // verify the required parameter 'relative_path' is set
        if ($relative_path === null || (is_array($relative_path) && count($relative_path) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $relative_path when calling getCourseAsset'
            );
        }

        $resourcePath = '/courses/{courseId}/asset';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($relative_path !== null) {
            $queryParams['relativePath'] = ObjectSerializer::toQueryValue($relative_path);
        }

        // path params
        if ($course_id !== null) {
            $resourcePath = str_replace(
                '{' . 'courseId' . '}',
                ObjectSerializer::toPathValue($course_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/octet-stream']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/octet-stream'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;

            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCourseConfiguration
     *
     * Get effective configuration settings for a Course
     *
     * @param  string $course_id course_id (required)
     * @param  bool $include_metadata include_metadata (optional, default to false)
     *
     * @throws \RusticiSoftware\Cloud\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \RusticiSoftware\Cloud\V2\Model\SettingListSchema
     */
    public function getCourseConfiguration($course_id, $include_metadata = 'false')
    {
        list($response) = $this->getCourseConfigurationWithHttpInfo($course_id, $include_metadata);
        return $response;
    }

    /**
     * Operation getCourseConfigurationWithHttpInfo
     *
     * Get effective configuration settings for a Course
     *
     * @param  string $course_id (required)
     * @param  bool $include_metadata (optional, default to false)
     *
     * @throws \RusticiSoftware\Cloud\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \RusticiSoftware\Cloud\V2\Model\SettingListSchema, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCourseConfigurationWithHttpInfo($course_id, $include_metadata = 'false')
    {
        $returnType = '\RusticiSoftware\Cloud\V2\Model\SettingListSchema';
        $request = $this->getCourseConfigurationRequest($course_id, $include_metadata);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Cloud\V2\Model\SettingListSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Cloud\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Cloud\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getCourseConfigurationAsync
     *
     * Get effective configuration settings for a Course
     *
     * @param  string $course_id (required)
     * @param  bool $include_metadata (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCourseConfigurationAsync($course_id, $include_metadata = 'false')
    {
        return $this->getCourseConfigurationAsyncWithHttpInfo($course_id, $include_metadata)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCourseConfigurationAsyncWithHttpInfo
     *
     * Get effective configuration settings for a Course
     *
     * @param  string $course_id (required)
     * @param  bool $include_metadata (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCourseConfigurationAsyncWithHttpInfo($course_id, $include_metadata = 'false')
    {
        $returnType = '\RusticiSoftware\Cloud\V2\Model\SettingListSchema';
        $request = $this->getCourseConfigurationRequest($course_id, $include_metadata);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCourseConfiguration'
     *
     * @param  string $course_id (required)
     * @param  bool $include_metadata (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getCourseConfigurationRequest($course_id, $include_metadata = 'false')
    {
        // verify the required parameter 'course_id' is set
        if ($course_id === null || (is_array($course_id) && count($course_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $course_id when calling getCourseConfiguration'
            );
        }

        $resourcePath = '/courses/{courseId}/configuration';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($include_metadata !== null) {
            $queryParams['includeMetadata'] = ObjectSerializer::toQueryValue($include_metadata);
        }

        // path params
        if ($course_id !== null) {
            $resourcePath = str_replace(
                '{' . 'courseId' . '}',
                ObjectSerializer::toPathValue($course_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;

            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCourseFileList
     *
     * Get a list of asset files in a Course
     *
     * @param  string $course_id course_id (required)
     *
     * @throws \RusticiSoftware\Cloud\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \RusticiSoftware\Cloud\V2\Model\FileListSchema
     */
    public function getCourseFileList($course_id)
    {
        list($response) = $this->getCourseFileListWithHttpInfo($course_id);
        return $response;
    }

    /**
     * Operation getCourseFileListWithHttpInfo
     *
     * Get a list of asset files in a Course
     *
     * @param  string $course_id (required)
     *
     * @throws \RusticiSoftware\Cloud\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \RusticiSoftware\Cloud\V2\Model\FileListSchema, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCourseFileListWithHttpInfo($course_id)
    {
        $returnType = '\RusticiSoftware\Cloud\V2\Model\FileListSchema';
        $request = $this->getCourseFileListRequest($course_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Cloud\V2\Model\FileListSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Cloud\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Cloud\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getCourseFileListAsync
     *
     * Get a list of asset files in a Course
     *
     * @param  string $course_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCourseFileListAsync($course_id)
    {
        return $this->getCourseFileListAsyncWithHttpInfo($course_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCourseFileListAsyncWithHttpInfo
     *
     * Get a list of asset files in a Course
     *
     * @param  string $course_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCourseFileListAsyncWithHttpInfo($course_id)
    {
        $returnType = '\RusticiSoftware\Cloud\V2\Model\FileListSchema';
        $request = $this->getCourseFileListRequest($course_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCourseFileList'
     *
     * @param  string $course_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getCourseFileListRequest($course_id)
    {
        // verify the required parameter 'course_id' is set
        if ($course_id === null || (is_array($course_id) && count($course_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $course_id when calling getCourseFileList'
            );
        }

        $resourcePath = '/courses/{courseId}/asset/list';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($course_id !== null) {
            $resourcePath = str_replace(
                '{' . 'courseId' . '}',
                ObjectSerializer::toPathValue($course_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;

            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCourseStatements
     *
     * Get xAPI statements for a Course
     *
     * @param  string $course_id course_id (required)
     * @param  string $learner_id Only entries for the specified learner id will be included. (optional)
     * @param  \DateTime $since Filter by ISO 8601 TimeStamp inclusive (defaults to UTC) (optional)
     * @param  \DateTime $until Filter by ISO 8601 TimeStamp inclusive (defaults to UTC) (optional)
     * @param  string $more Pagination token returned as &#x60;more&#x60; property of multi page list requests (optional)
     *
     * @throws \RusticiSoftware\Cloud\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \RusticiSoftware\Cloud\V2\Model\XapiStatementResult
     */
    public function getCourseStatements($course_id, $learner_id = null, $since = null, $until = null, $more = null)
    {
        list($response) = $this->getCourseStatementsWithHttpInfo($course_id, $learner_id, $since, $until, $more);
        return $response;
    }

    /**
     * Operation getCourseStatementsWithHttpInfo
     *
     * Get xAPI statements for a Course
     *
     * @param  string $course_id (required)
     * @param  string $learner_id Only entries for the specified learner id will be included. (optional)
     * @param  \DateTime $since Filter by ISO 8601 TimeStamp inclusive (defaults to UTC) (optional)
     * @param  \DateTime $until Filter by ISO 8601 TimeStamp inclusive (defaults to UTC) (optional)
     * @param  string $more Pagination token returned as &#x60;more&#x60; property of multi page list requests (optional)
     *
     * @throws \RusticiSoftware\Cloud\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \RusticiSoftware\Cloud\V2\Model\XapiStatementResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCourseStatementsWithHttpInfo($course_id, $learner_id = null, $since = null, $until = null, $more = null)
    {
        $returnType = '\RusticiSoftware\Cloud\V2\Model\XapiStatementResult';
        $request = $this->getCourseStatementsRequest($course_id, $learner_id, $since, $until, $more);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Cloud\V2\Model\XapiStatementResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Cloud\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Cloud\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getCourseStatementsAsync
     *
     * Get xAPI statements for a Course
     *
     * @param  string $course_id (required)
     * @param  string $learner_id Only entries for the specified learner id will be included. (optional)
     * @param  \DateTime $since Filter by ISO 8601 TimeStamp inclusive (defaults to UTC) (optional)
     * @param  \DateTime $until Filter by ISO 8601 TimeStamp inclusive (defaults to UTC) (optional)
     * @param  string $more Pagination token returned as &#x60;more&#x60; property of multi page list requests (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCourseStatementsAsync($course_id, $learner_id = null, $since = null, $until = null, $more = null)
    {
        return $this->getCourseStatementsAsyncWithHttpInfo($course_id, $learner_id, $since, $until, $more)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCourseStatementsAsyncWithHttpInfo
     *
     * Get xAPI statements for a Course
     *
     * @param  string $course_id (required)
     * @param  string $learner_id Only entries for the specified learner id will be included. (optional)
     * @param  \DateTime $since Filter by ISO 8601 TimeStamp inclusive (defaults to UTC) (optional)
     * @param  \DateTime $until Filter by ISO 8601 TimeStamp inclusive (defaults to UTC) (optional)
     * @param  string $more Pagination token returned as &#x60;more&#x60; property of multi page list requests (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCourseStatementsAsyncWithHttpInfo($course_id, $learner_id = null, $since = null, $until = null, $more = null)
    {
        $returnType = '\RusticiSoftware\Cloud\V2\Model\XapiStatementResult';
        $request = $this->getCourseStatementsRequest($course_id, $learner_id, $since, $until, $more);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCourseStatements'
     *
     * @param  string $course_id (required)
     * @param  string $learner_id Only entries for the specified learner id will be included. (optional)
     * @param  \DateTime $since Filter by ISO 8601 TimeStamp inclusive (defaults to UTC) (optional)
     * @param  \DateTime $until Filter by ISO 8601 TimeStamp inclusive (defaults to UTC) (optional)
     * @param  string $more Pagination token returned as &#x60;more&#x60; property of multi page list requests (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getCourseStatementsRequest($course_id, $learner_id = null, $since = null, $until = null, $more = null)
    {
        // verify the required parameter 'course_id' is set
        if ($course_id === null || (is_array($course_id) && count($course_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $course_id when calling getCourseStatements'
            );
        }

        $resourcePath = '/courses/{courseId}/xAPIStatements';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($learner_id !== null) {
            $queryParams['learnerId'] = ObjectSerializer::toQueryValue($learner_id);
        }
        // query params
        if ($since !== null) {
            $queryParams['since'] = ObjectSerializer::toQueryValue($since);
        }
        // query params
        if ($until !== null) {
            $queryParams['until'] = ObjectSerializer::toQueryValue($until);
        }
        // query params
        if ($more !== null) {
            $queryParams['more'] = ObjectSerializer::toQueryValue($more);
        }

        // path params
        if ($course_id !== null) {
            $resourcePath = str_replace(
                '{' . 'courseId' . '}',
                ObjectSerializer::toPathValue($course_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;

            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCourseTags
     *
     * Get tags for a Course
     *
     * @param  string $course_id course_id (required)
     *
     * @throws \RusticiSoftware\Cloud\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \RusticiSoftware\Cloud\V2\Model\TagListSchema
     */
    public function getCourseTags($course_id)
    {
        list($response) = $this->getCourseTagsWithHttpInfo($course_id);
        return $response;
    }

    /**
     * Operation getCourseTagsWithHttpInfo
     *
     * Get tags for a Course
     *
     * @param  string $course_id (required)
     *
     * @throws \RusticiSoftware\Cloud\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \RusticiSoftware\Cloud\V2\Model\TagListSchema, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCourseTagsWithHttpInfo($course_id)
    {
        $returnType = '\RusticiSoftware\Cloud\V2\Model\TagListSchema';
        $request = $this->getCourseTagsRequest($course_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Cloud\V2\Model\TagListSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Cloud\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Cloud\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getCourseTagsAsync
     *
     * Get tags for a Course
     *
     * @param  string $course_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCourseTagsAsync($course_id)
    {
        return $this->getCourseTagsAsyncWithHttpInfo($course_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCourseTagsAsyncWithHttpInfo
     *
     * Get tags for a Course
     *
     * @param  string $course_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCourseTagsAsyncWithHttpInfo($course_id)
    {
        $returnType = '\RusticiSoftware\Cloud\V2\Model\TagListSchema';
        $request = $this->getCourseTagsRequest($course_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCourseTags'
     *
     * @param  string $course_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getCourseTagsRequest($course_id)
    {
        // verify the required parameter 'course_id' is set
        if ($course_id === null || (is_array($course_id) && count($course_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $course_id when calling getCourseTags'
            );
        }

        $resourcePath = '/courses/{courseId}/tags';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($course_id !== null) {
            $resourcePath = str_replace(
                '{' . 'courseId' . '}',
                ObjectSerializer::toPathValue($course_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;

            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCourseVersionAsset
     *
     * Download an asset file from a specific Course Version
     *
     * @param  string $course_id course_id (required)
     * @param  int $version_id version_id (required)
     * @param  string $relative_path Relative path of the asset within the course. (required)
     *
     * @throws \RusticiSoftware\Cloud\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getCourseVersionAsset($course_id, $version_id, $relative_path)
    {
        list($response) = $this->getCourseVersionAssetWithHttpInfo($course_id, $version_id, $relative_path);
        return $response;
    }

    /**
     * Operation getCourseVersionAssetWithHttpInfo
     *
     * Download an asset file from a specific Course Version
     *
     * @param  string $course_id (required)
     * @param  int $version_id (required)
     * @param  string $relative_path Relative path of the asset within the course. (required)
     *
     * @throws \RusticiSoftware\Cloud\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCourseVersionAssetWithHttpInfo($course_id, $version_id, $relative_path)
    {
        $returnType = '\SplFileObject';
        $request = $this->getCourseVersionAssetRequest($course_id, $version_id, $relative_path);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Cloud\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Cloud\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getCourseVersionAssetAsync
     *
     * Download an asset file from a specific Course Version
     *
     * @param  string $course_id (required)
     * @param  int $version_id (required)
     * @param  string $relative_path Relative path of the asset within the course. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCourseVersionAssetAsync($course_id, $version_id, $relative_path)
    {
        return $this->getCourseVersionAssetAsyncWithHttpInfo($course_id, $version_id, $relative_path)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCourseVersionAssetAsyncWithHttpInfo
     *
     * Download an asset file from a specific Course Version
     *
     * @param  string $course_id (required)
     * @param  int $version_id (required)
     * @param  string $relative_path Relative path of the asset within the course. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCourseVersionAssetAsyncWithHttpInfo($course_id, $version_id, $relative_path)
    {
        $returnType = '\SplFileObject';
        $request = $this->getCourseVersionAssetRequest($course_id, $version_id, $relative_path);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCourseVersionAsset'
     *
     * @param  string $course_id (required)
     * @param  int $version_id (required)
     * @param  string $relative_path Relative path of the asset within the course. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getCourseVersionAssetRequest($course_id, $version_id, $relative_path)
    {
        // verify the required parameter 'course_id' is set
        if ($course_id === null || (is_array($course_id) && count($course_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $course_id when calling getCourseVersionAsset'
            );
        }
        // verify the required parameter 'version_id' is set
        if ($version_id === null || (is_array($version_id) && count($version_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version_id when calling getCourseVersionAsset'
            );
        }
        // verify the required parameter 'relative_path' is set
        if ($relative_path === null || (is_array($relative_path) && count($relative_path) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $relative_path when calling getCourseVersionAsset'
            );
        }

        $resourcePath = '/courses/{courseId}/versions/{versionId}/asset';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($relative_path !== null) {
            $queryParams['relativePath'] = ObjectSerializer::toQueryValue($relative_path);
        }

        // path params
        if ($course_id !== null) {
            $resourcePath = str_replace(
                '{' . 'courseId' . '}',
                ObjectSerializer::toPathValue($course_id),
                $resourcePath
            );
        }
        // path params
        if ($version_id !== null) {
            $resourcePath = str_replace(
                '{' . 'versionId' . '}',
                ObjectSerializer::toPathValue($version_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/octet-stream']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/octet-stream'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;

            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCourseVersionConfiguration
     *
     * Get effective configuration settings for a Course Version
     *
     * @param  string $course_id course_id (required)
     * @param  int $version_id version_id (required)
     * @param  bool $include_metadata include_metadata (optional, default to false)
     *
     * @throws \RusticiSoftware\Cloud\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \RusticiSoftware\Cloud\V2\Model\SettingListSchema
     */
    public function getCourseVersionConfiguration($course_id, $version_id, $include_metadata = 'false')
    {
        list($response) = $this->getCourseVersionConfigurationWithHttpInfo($course_id, $version_id, $include_metadata);
        return $response;
    }

    /**
     * Operation getCourseVersionConfigurationWithHttpInfo
     *
     * Get effective configuration settings for a Course Version
     *
     * @param  string $course_id (required)
     * @param  int $version_id (required)
     * @param  bool $include_metadata (optional, default to false)
     *
     * @throws \RusticiSoftware\Cloud\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \RusticiSoftware\Cloud\V2\Model\SettingListSchema, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCourseVersionConfigurationWithHttpInfo($course_id, $version_id, $include_metadata = 'false')
    {
        $returnType = '\RusticiSoftware\Cloud\V2\Model\SettingListSchema';
        $request = $this->getCourseVersionConfigurationRequest($course_id, $version_id, $include_metadata);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Cloud\V2\Model\SettingListSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Cloud\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Cloud\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getCourseVersionConfigurationAsync
     *
     * Get effective configuration settings for a Course Version
     *
     * @param  string $course_id (required)
     * @param  int $version_id (required)
     * @param  bool $include_metadata (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCourseVersionConfigurationAsync($course_id, $version_id, $include_metadata = 'false')
    {
        return $this->getCourseVersionConfigurationAsyncWithHttpInfo($course_id, $version_id, $include_metadata)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCourseVersionConfigurationAsyncWithHttpInfo
     *
     * Get effective configuration settings for a Course Version
     *
     * @param  string $course_id (required)
     * @param  int $version_id (required)
     * @param  bool $include_metadata (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCourseVersionConfigurationAsyncWithHttpInfo($course_id, $version_id, $include_metadata = 'false')
    {
        $returnType = '\RusticiSoftware\Cloud\V2\Model\SettingListSchema';
        $request = $this->getCourseVersionConfigurationRequest($course_id, $version_id, $include_metadata);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCourseVersionConfiguration'
     *
     * @param  string $course_id (required)
     * @param  int $version_id (required)
     * @param  bool $include_metadata (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getCourseVersionConfigurationRequest($course_id, $version_id, $include_metadata = 'false')
    {
        // verify the required parameter 'course_id' is set
        if ($course_id === null || (is_array($course_id) && count($course_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $course_id when calling getCourseVersionConfiguration'
            );
        }
        // verify the required parameter 'version_id' is set
        if ($version_id === null || (is_array($version_id) && count($version_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version_id when calling getCourseVersionConfiguration'
            );
        }

        $resourcePath = '/courses/{courseId}/versions/{versionId}/configuration';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($include_metadata !== null) {
            $queryParams['includeMetadata'] = ObjectSerializer::toQueryValue($include_metadata);
        }

        // path params
        if ($course_id !== null) {
            $resourcePath = str_replace(
                '{' . 'courseId' . '}',
                ObjectSerializer::toPathValue($course_id),
                $resourcePath
            );
        }
        // path params
        if ($version_id !== null) {
            $resourcePath = str_replace(
                '{' . 'versionId' . '}',
                ObjectSerializer::toPathValue($version_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;

            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCourseVersionFileList
     *
     * Get a list of asset files in a Course Version
     *
     * @param  string $course_id course_id (required)
     * @param  int $version_id version_id (required)
     *
     * @throws \RusticiSoftware\Cloud\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \RusticiSoftware\Cloud\V2\Model\FileListSchema
     */
    public function getCourseVersionFileList($course_id, $version_id)
    {
        list($response) = $this->getCourseVersionFileListWithHttpInfo($course_id, $version_id);
        return $response;
    }

    /**
     * Operation getCourseVersionFileListWithHttpInfo
     *
     * Get a list of asset files in a Course Version
     *
     * @param  string $course_id (required)
     * @param  int $version_id (required)
     *
     * @throws \RusticiSoftware\Cloud\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \RusticiSoftware\Cloud\V2\Model\FileListSchema, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCourseVersionFileListWithHttpInfo($course_id, $version_id)
    {
        $returnType = '\RusticiSoftware\Cloud\V2\Model\FileListSchema';
        $request = $this->getCourseVersionFileListRequest($course_id, $version_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Cloud\V2\Model\FileListSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Cloud\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Cloud\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getCourseVersionFileListAsync
     *
     * Get a list of asset files in a Course Version
     *
     * @param  string $course_id (required)
     * @param  int $version_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCourseVersionFileListAsync($course_id, $version_id)
    {
        return $this->getCourseVersionFileListAsyncWithHttpInfo($course_id, $version_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCourseVersionFileListAsyncWithHttpInfo
     *
     * Get a list of asset files in a Course Version
     *
     * @param  string $course_id (required)
     * @param  int $version_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCourseVersionFileListAsyncWithHttpInfo($course_id, $version_id)
    {
        $returnType = '\RusticiSoftware\Cloud\V2\Model\FileListSchema';
        $request = $this->getCourseVersionFileListRequest($course_id, $version_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCourseVersionFileList'
     *
     * @param  string $course_id (required)
     * @param  int $version_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getCourseVersionFileListRequest($course_id, $version_id)
    {
        // verify the required parameter 'course_id' is set
        if ($course_id === null || (is_array($course_id) && count($course_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $course_id when calling getCourseVersionFileList'
            );
        }
        // verify the required parameter 'version_id' is set
        if ($version_id === null || (is_array($version_id) && count($version_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version_id when calling getCourseVersionFileList'
            );
        }

        $resourcePath = '/courses/{courseId}/versions/{versionId}/asset/list';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($course_id !== null) {
            $resourcePath = str_replace(
                '{' . 'courseId' . '}',
                ObjectSerializer::toPathValue($course_id),
                $resourcePath
            );
        }
        // path params
        if ($version_id !== null) {
            $resourcePath = str_replace(
                '{' . 'versionId' . '}',
                ObjectSerializer::toPathValue($version_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;

            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCourseVersionInfo
     *
     * Get detailed information about a Course Version
     *
     * @param  string $course_id course_id (required)
     * @param  int $version_id version_id (required)
     * @param  bool $include_registration_count Include the registration count in the results (optional, default to false)
     * @param  bool $include_course_metadata Include course metadata in the results. If the course has no metadata, adding this parameter has no effect. (optional, default to false)
     *
     * @throws \RusticiSoftware\Cloud\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \RusticiSoftware\Cloud\V2\Model\CourseSchema
     */
    public function getCourseVersionInfo($course_id, $version_id, $include_registration_count = 'false', $include_course_metadata = 'false')
    {
        list($response) = $this->getCourseVersionInfoWithHttpInfo($course_id, $version_id, $include_registration_count, $include_course_metadata);
        return $response;
    }

    /**
     * Operation getCourseVersionInfoWithHttpInfo
     *
     * Get detailed information about a Course Version
     *
     * @param  string $course_id (required)
     * @param  int $version_id (required)
     * @param  bool $include_registration_count Include the registration count in the results (optional, default to false)
     * @param  bool $include_course_metadata Include course metadata in the results. If the course has no metadata, adding this parameter has no effect. (optional, default to false)
     *
     * @throws \RusticiSoftware\Cloud\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \RusticiSoftware\Cloud\V2\Model\CourseSchema, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCourseVersionInfoWithHttpInfo($course_id, $version_id, $include_registration_count = 'false', $include_course_metadata = 'false')
    {
        $returnType = '\RusticiSoftware\Cloud\V2\Model\CourseSchema';
        $request = $this->getCourseVersionInfoRequest($course_id, $version_id, $include_registration_count, $include_course_metadata);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Cloud\V2\Model\CourseSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Cloud\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Cloud\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getCourseVersionInfoAsync
     *
     * Get detailed information about a Course Version
     *
     * @param  string $course_id (required)
     * @param  int $version_id (required)
     * @param  bool $include_registration_count Include the registration count in the results (optional, default to false)
     * @param  bool $include_course_metadata Include course metadata in the results. If the course has no metadata, adding this parameter has no effect. (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCourseVersionInfoAsync($course_id, $version_id, $include_registration_count = 'false', $include_course_metadata = 'false')
    {
        return $this->getCourseVersionInfoAsyncWithHttpInfo($course_id, $version_id, $include_registration_count, $include_course_metadata)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCourseVersionInfoAsyncWithHttpInfo
     *
     * Get detailed information about a Course Version
     *
     * @param  string $course_id (required)
     * @param  int $version_id (required)
     * @param  bool $include_registration_count Include the registration count in the results (optional, default to false)
     * @param  bool $include_course_metadata Include course metadata in the results. If the course has no metadata, adding this parameter has no effect. (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCourseVersionInfoAsyncWithHttpInfo($course_id, $version_id, $include_registration_count = 'false', $include_course_metadata = 'false')
    {
        $returnType = '\RusticiSoftware\Cloud\V2\Model\CourseSchema';
        $request = $this->getCourseVersionInfoRequest($course_id, $version_id, $include_registration_count, $include_course_metadata);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCourseVersionInfo'
     *
     * @param  string $course_id (required)
     * @param  int $version_id (required)
     * @param  bool $include_registration_count Include the registration count in the results (optional, default to false)
     * @param  bool $include_course_metadata Include course metadata in the results. If the course has no metadata, adding this parameter has no effect. (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getCourseVersionInfoRequest($course_id, $version_id, $include_registration_count = 'false', $include_course_metadata = 'false')
    {
        // verify the required parameter 'course_id' is set
        if ($course_id === null || (is_array($course_id) && count($course_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $course_id when calling getCourseVersionInfo'
            );
        }
        // verify the required parameter 'version_id' is set
        if ($version_id === null || (is_array($version_id) && count($version_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version_id when calling getCourseVersionInfo'
            );
        }

        $resourcePath = '/courses/{courseId}/versions/{versionId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($include_registration_count !== null) {
            $queryParams['includeRegistrationCount'] = ObjectSerializer::toQueryValue($include_registration_count);
        }
        // query params
        if ($include_course_metadata !== null) {
            $queryParams['includeCourseMetadata'] = ObjectSerializer::toQueryValue($include_course_metadata);
        }

        // path params
        if ($course_id !== null) {
            $resourcePath = str_replace(
                '{' . 'courseId' . '}',
                ObjectSerializer::toPathValue($course_id),
                $resourcePath
            );
        }
        // path params
        if ($version_id !== null) {
            $resourcePath = str_replace(
                '{' . 'versionId' . '}',
                ObjectSerializer::toPathValue($version_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;

            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCourseVersionStatements
     *
     * Get xAPI statements for a Course Version
     *
     * @param  string $course_id course_id (required)
     * @param  int $version_id version_id (required)
     * @param  string $learner_id Only entries for the specified learner id will be included. (optional)
     * @param  \DateTime $since Filter by ISO 8601 TimeStamp inclusive (defaults to UTC) (optional)
     * @param  \DateTime $until Filter by ISO 8601 TimeStamp inclusive (defaults to UTC) (optional)
     * @param  string $more Pagination token returned as &#x60;more&#x60; property of multi page list requests (optional)
     *
     * @throws \RusticiSoftware\Cloud\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \RusticiSoftware\Cloud\V2\Model\XapiStatementResult
     */
    public function getCourseVersionStatements($course_id, $version_id, $learner_id = null, $since = null, $until = null, $more = null)
    {
        list($response) = $this->getCourseVersionStatementsWithHttpInfo($course_id, $version_id, $learner_id, $since, $until, $more);
        return $response;
    }

    /**
     * Operation getCourseVersionStatementsWithHttpInfo
     *
     * Get xAPI statements for a Course Version
     *
     * @param  string $course_id (required)
     * @param  int $version_id (required)
     * @param  string $learner_id Only entries for the specified learner id will be included. (optional)
     * @param  \DateTime $since Filter by ISO 8601 TimeStamp inclusive (defaults to UTC) (optional)
     * @param  \DateTime $until Filter by ISO 8601 TimeStamp inclusive (defaults to UTC) (optional)
     * @param  string $more Pagination token returned as &#x60;more&#x60; property of multi page list requests (optional)
     *
     * @throws \RusticiSoftware\Cloud\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \RusticiSoftware\Cloud\V2\Model\XapiStatementResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCourseVersionStatementsWithHttpInfo($course_id, $version_id, $learner_id = null, $since = null, $until = null, $more = null)
    {
        $returnType = '\RusticiSoftware\Cloud\V2\Model\XapiStatementResult';
        $request = $this->getCourseVersionStatementsRequest($course_id, $version_id, $learner_id, $since, $until, $more);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Cloud\V2\Model\XapiStatementResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Cloud\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Cloud\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getCourseVersionStatementsAsync
     *
     * Get xAPI statements for a Course Version
     *
     * @param  string $course_id (required)
     * @param  int $version_id (required)
     * @param  string $learner_id Only entries for the specified learner id will be included. (optional)
     * @param  \DateTime $since Filter by ISO 8601 TimeStamp inclusive (defaults to UTC) (optional)
     * @param  \DateTime $until Filter by ISO 8601 TimeStamp inclusive (defaults to UTC) (optional)
     * @param  string $more Pagination token returned as &#x60;more&#x60; property of multi page list requests (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCourseVersionStatementsAsync($course_id, $version_id, $learner_id = null, $since = null, $until = null, $more = null)
    {
        return $this->getCourseVersionStatementsAsyncWithHttpInfo($course_id, $version_id, $learner_id, $since, $until, $more)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCourseVersionStatementsAsyncWithHttpInfo
     *
     * Get xAPI statements for a Course Version
     *
     * @param  string $course_id (required)
     * @param  int $version_id (required)
     * @param  string $learner_id Only entries for the specified learner id will be included. (optional)
     * @param  \DateTime $since Filter by ISO 8601 TimeStamp inclusive (defaults to UTC) (optional)
     * @param  \DateTime $until Filter by ISO 8601 TimeStamp inclusive (defaults to UTC) (optional)
     * @param  string $more Pagination token returned as &#x60;more&#x60; property of multi page list requests (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCourseVersionStatementsAsyncWithHttpInfo($course_id, $version_id, $learner_id = null, $since = null, $until = null, $more = null)
    {
        $returnType = '\RusticiSoftware\Cloud\V2\Model\XapiStatementResult';
        $request = $this->getCourseVersionStatementsRequest($course_id, $version_id, $learner_id, $since, $until, $more);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCourseVersionStatements'
     *
     * @param  string $course_id (required)
     * @param  int $version_id (required)
     * @param  string $learner_id Only entries for the specified learner id will be included. (optional)
     * @param  \DateTime $since Filter by ISO 8601 TimeStamp inclusive (defaults to UTC) (optional)
     * @param  \DateTime $until Filter by ISO 8601 TimeStamp inclusive (defaults to UTC) (optional)
     * @param  string $more Pagination token returned as &#x60;more&#x60; property of multi page list requests (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getCourseVersionStatementsRequest($course_id, $version_id, $learner_id = null, $since = null, $until = null, $more = null)
    {
        // verify the required parameter 'course_id' is set
        if ($course_id === null || (is_array($course_id) && count($course_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $course_id when calling getCourseVersionStatements'
            );
        }
        // verify the required parameter 'version_id' is set
        if ($version_id === null || (is_array($version_id) && count($version_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version_id when calling getCourseVersionStatements'
            );
        }

        $resourcePath = '/courses/{courseId}/versions/{versionId}/xAPIStatements';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($learner_id !== null) {
            $queryParams['learnerId'] = ObjectSerializer::toQueryValue($learner_id);
        }
        // query params
        if ($since !== null) {
            $queryParams['since'] = ObjectSerializer::toQueryValue($since);
        }
        // query params
        if ($until !== null) {
            $queryParams['until'] = ObjectSerializer::toQueryValue($until);
        }
        // query params
        if ($more !== null) {
            $queryParams['more'] = ObjectSerializer::toQueryValue($more);
        }

        // path params
        if ($course_id !== null) {
            $resourcePath = str_replace(
                '{' . 'courseId' . '}',
                ObjectSerializer::toPathValue($course_id),
                $resourcePath
            );
        }
        // path params
        if ($version_id !== null) {
            $resourcePath = str_replace(
                '{' . 'versionId' . '}',
                ObjectSerializer::toPathValue($version_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;

            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCourseVersions
     *
     * Get a list of a Course's Versions
     *
     * @param  string $course_id course_id (required)
     * @param  \DateTime $since Filter by ISO 8601 TimeStamp inclusive (defaults to UTC) (optional)
     * @param  \DateTime $until Filter by ISO 8601 TimeStamp inclusive (defaults to UTC) (optional)
     * @param  bool $include_registration_count Include the registration count in the results (optional, default to false)
     * @param  bool $include_course_metadata Include course metadata in the results. If the course has no metadata, adding this parameter has no effect. (optional, default to false)
     *
     * @throws \RusticiSoftware\Cloud\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \RusticiSoftware\Cloud\V2\Model\CourseListNonPagedSchema
     */
    public function getCourseVersions($course_id, $since = null, $until = null, $include_registration_count = 'false', $include_course_metadata = 'false')
    {
        list($response) = $this->getCourseVersionsWithHttpInfo($course_id, $since, $until, $include_registration_count, $include_course_metadata);
        return $response;
    }

    /**
     * Operation getCourseVersionsWithHttpInfo
     *
     * Get a list of a Course's Versions
     *
     * @param  string $course_id (required)
     * @param  \DateTime $since Filter by ISO 8601 TimeStamp inclusive (defaults to UTC) (optional)
     * @param  \DateTime $until Filter by ISO 8601 TimeStamp inclusive (defaults to UTC) (optional)
     * @param  bool $include_registration_count Include the registration count in the results (optional, default to false)
     * @param  bool $include_course_metadata Include course metadata in the results. If the course has no metadata, adding this parameter has no effect. (optional, default to false)
     *
     * @throws \RusticiSoftware\Cloud\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \RusticiSoftware\Cloud\V2\Model\CourseListNonPagedSchema, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCourseVersionsWithHttpInfo($course_id, $since = null, $until = null, $include_registration_count = 'false', $include_course_metadata = 'false')
    {
        $returnType = '\RusticiSoftware\Cloud\V2\Model\CourseListNonPagedSchema';
        $request = $this->getCourseVersionsRequest($course_id, $since, $until, $include_registration_count, $include_course_metadata);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Cloud\V2\Model\CourseListNonPagedSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Cloud\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Cloud\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getCourseVersionsAsync
     *
     * Get a list of a Course's Versions
     *
     * @param  string $course_id (required)
     * @param  \DateTime $since Filter by ISO 8601 TimeStamp inclusive (defaults to UTC) (optional)
     * @param  \DateTime $until Filter by ISO 8601 TimeStamp inclusive (defaults to UTC) (optional)
     * @param  bool $include_registration_count Include the registration count in the results (optional, default to false)
     * @param  bool $include_course_metadata Include course metadata in the results. If the course has no metadata, adding this parameter has no effect. (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCourseVersionsAsync($course_id, $since = null, $until = null, $include_registration_count = 'false', $include_course_metadata = 'false')
    {
        return $this->getCourseVersionsAsyncWithHttpInfo($course_id, $since, $until, $include_registration_count, $include_course_metadata)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCourseVersionsAsyncWithHttpInfo
     *
     * Get a list of a Course's Versions
     *
     * @param  string $course_id (required)
     * @param  \DateTime $since Filter by ISO 8601 TimeStamp inclusive (defaults to UTC) (optional)
     * @param  \DateTime $until Filter by ISO 8601 TimeStamp inclusive (defaults to UTC) (optional)
     * @param  bool $include_registration_count Include the registration count in the results (optional, default to false)
     * @param  bool $include_course_metadata Include course metadata in the results. If the course has no metadata, adding this parameter has no effect. (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCourseVersionsAsyncWithHttpInfo($course_id, $since = null, $until = null, $include_registration_count = 'false', $include_course_metadata = 'false')
    {
        $returnType = '\RusticiSoftware\Cloud\V2\Model\CourseListNonPagedSchema';
        $request = $this->getCourseVersionsRequest($course_id, $since, $until, $include_registration_count, $include_course_metadata);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCourseVersions'
     *
     * @param  string $course_id (required)
     * @param  \DateTime $since Filter by ISO 8601 TimeStamp inclusive (defaults to UTC) (optional)
     * @param  \DateTime $until Filter by ISO 8601 TimeStamp inclusive (defaults to UTC) (optional)
     * @param  bool $include_registration_count Include the registration count in the results (optional, default to false)
     * @param  bool $include_course_metadata Include course metadata in the results. If the course has no metadata, adding this parameter has no effect. (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getCourseVersionsRequest($course_id, $since = null, $until = null, $include_registration_count = 'false', $include_course_metadata = 'false')
    {
        // verify the required parameter 'course_id' is set
        if ($course_id === null || (is_array($course_id) && count($course_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $course_id when calling getCourseVersions'
            );
        }

        $resourcePath = '/courses/{courseId}/versions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($since !== null) {
            $queryParams['since'] = ObjectSerializer::toQueryValue($since);
        }
        // query params
        if ($until !== null) {
            $queryParams['until'] = ObjectSerializer::toQueryValue($until);
        }
        // query params
        if ($include_registration_count !== null) {
            $queryParams['includeRegistrationCount'] = ObjectSerializer::toQueryValue($include_registration_count);
        }
        // query params
        if ($include_course_metadata !== null) {
            $queryParams['includeCourseMetadata'] = ObjectSerializer::toQueryValue($include_course_metadata);
        }

        // path params
        if ($course_id !== null) {
            $resourcePath = str_replace(
                '{' . 'courseId' . '}',
                ObjectSerializer::toPathValue($course_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;

            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCourses
     *
     * Get a list of Courses
     *
     * @param  \DateTime $since Filter by ISO 8601 TimeStamp inclusive (defaults to UTC) (optional)
     * @param  \DateTime $until Filter by ISO 8601 TimeStamp inclusive (defaults to UTC) (optional)
     * @param  string $datetime_filter Specifies field that &#x60;since&#x60; and &#x60;until&#x60; parameters are applied against (optional, default to updated)
     * @param  string[] $tags Filter items matching any tag provided (not all) (optional)
     * @param  string $filter Optional string which filters results by a specified field (described by filterBy). (optional)
     * @param  string $filter_by Optional enum parameter for specifying the field on which to run the filter. (optional, default to course_id)
     * @param  string $order_by Optional enum parameter for specifying the field and order by which to sort the results. (optional, default to created_desc)
     * @param  string $more Pagination token returned as &#x60;more&#x60; property of multi page list requests (optional)
     * @param  bool $include_course_metadata Include course metadata in the results. If the course has no metadata, adding this parameter has no effect. (optional, default to false)
     * @param  bool $include_registration_count Include the registration count in the results (optional, default to false)
     *
     * @throws \RusticiSoftware\Cloud\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \RusticiSoftware\Cloud\V2\Model\CourseListSchema
     */
    public function getCourses($since = null, $until = null, $datetime_filter = 'updated', $tags = null, $filter = null, $filter_by = 'course_id', $order_by = 'created_desc', $more = null, $include_course_metadata = 'false', $include_registration_count = 'false')
    {
        list($response) = $this->getCoursesWithHttpInfo($since, $until, $datetime_filter, $tags, $filter, $filter_by, $order_by, $more, $include_course_metadata, $include_registration_count);
        return $response;
    }

    /**
     * Operation getCoursesWithHttpInfo
     *
     * Get a list of Courses
     *
     * @param  \DateTime $since Filter by ISO 8601 TimeStamp inclusive (defaults to UTC) (optional)
     * @param  \DateTime $until Filter by ISO 8601 TimeStamp inclusive (defaults to UTC) (optional)
     * @param  string $datetime_filter Specifies field that &#x60;since&#x60; and &#x60;until&#x60; parameters are applied against (optional, default to updated)
     * @param  string[] $tags Filter items matching any tag provided (not all) (optional)
     * @param  string $filter Optional string which filters results by a specified field (described by filterBy). (optional)
     * @param  string $filter_by Optional enum parameter for specifying the field on which to run the filter. (optional, default to course_id)
     * @param  string $order_by Optional enum parameter for specifying the field and order by which to sort the results. (optional, default to created_desc)
     * @param  string $more Pagination token returned as &#x60;more&#x60; property of multi page list requests (optional)
     * @param  bool $include_course_metadata Include course metadata in the results. If the course has no metadata, adding this parameter has no effect. (optional, default to false)
     * @param  bool $include_registration_count Include the registration count in the results (optional, default to false)
     *
     * @throws \RusticiSoftware\Cloud\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \RusticiSoftware\Cloud\V2\Model\CourseListSchema, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCoursesWithHttpInfo($since = null, $until = null, $datetime_filter = 'updated', $tags = null, $filter = null, $filter_by = 'course_id', $order_by = 'created_desc', $more = null, $include_course_metadata = 'false', $include_registration_count = 'false')
    {
        $returnType = '\RusticiSoftware\Cloud\V2\Model\CourseListSchema';
        $request = $this->getCoursesRequest($since, $until, $datetime_filter, $tags, $filter, $filter_by, $order_by, $more, $include_course_metadata, $include_registration_count);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Cloud\V2\Model\CourseListSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Cloud\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getCoursesAsync
     *
     * Get a list of Courses
     *
     * @param  \DateTime $since Filter by ISO 8601 TimeStamp inclusive (defaults to UTC) (optional)
     * @param  \DateTime $until Filter by ISO 8601 TimeStamp inclusive (defaults to UTC) (optional)
     * @param  string $datetime_filter Specifies field that &#x60;since&#x60; and &#x60;until&#x60; parameters are applied against (optional, default to updated)
     * @param  string[] $tags Filter items matching any tag provided (not all) (optional)
     * @param  string $filter Optional string which filters results by a specified field (described by filterBy). (optional)
     * @param  string $filter_by Optional enum parameter for specifying the field on which to run the filter. (optional, default to course_id)
     * @param  string $order_by Optional enum parameter for specifying the field and order by which to sort the results. (optional, default to created_desc)
     * @param  string $more Pagination token returned as &#x60;more&#x60; property of multi page list requests (optional)
     * @param  bool $include_course_metadata Include course metadata in the results. If the course has no metadata, adding this parameter has no effect. (optional, default to false)
     * @param  bool $include_registration_count Include the registration count in the results (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCoursesAsync($since = null, $until = null, $datetime_filter = 'updated', $tags = null, $filter = null, $filter_by = 'course_id', $order_by = 'created_desc', $more = null, $include_course_metadata = 'false', $include_registration_count = 'false')
    {
        return $this->getCoursesAsyncWithHttpInfo($since, $until, $datetime_filter, $tags, $filter, $filter_by, $order_by, $more, $include_course_metadata, $include_registration_count)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCoursesAsyncWithHttpInfo
     *
     * Get a list of Courses
     *
     * @param  \DateTime $since Filter by ISO 8601 TimeStamp inclusive (defaults to UTC) (optional)
     * @param  \DateTime $until Filter by ISO 8601 TimeStamp inclusive (defaults to UTC) (optional)
     * @param  string $datetime_filter Specifies field that &#x60;since&#x60; and &#x60;until&#x60; parameters are applied against (optional, default to updated)
     * @param  string[] $tags Filter items matching any tag provided (not all) (optional)
     * @param  string $filter Optional string which filters results by a specified field (described by filterBy). (optional)
     * @param  string $filter_by Optional enum parameter for specifying the field on which to run the filter. (optional, default to course_id)
     * @param  string $order_by Optional enum parameter for specifying the field and order by which to sort the results. (optional, default to created_desc)
     * @param  string $more Pagination token returned as &#x60;more&#x60; property of multi page list requests (optional)
     * @param  bool $include_course_metadata Include course metadata in the results. If the course has no metadata, adding this parameter has no effect. (optional, default to false)
     * @param  bool $include_registration_count Include the registration count in the results (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCoursesAsyncWithHttpInfo($since = null, $until = null, $datetime_filter = 'updated', $tags = null, $filter = null, $filter_by = 'course_id', $order_by = 'created_desc', $more = null, $include_course_metadata = 'false', $include_registration_count = 'false')
    {
        $returnType = '\RusticiSoftware\Cloud\V2\Model\CourseListSchema';
        $request = $this->getCoursesRequest($since, $until, $datetime_filter, $tags, $filter, $filter_by, $order_by, $more, $include_course_metadata, $include_registration_count);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCourses'
     *
     * @param  \DateTime $since Filter by ISO 8601 TimeStamp inclusive (defaults to UTC) (optional)
     * @param  \DateTime $until Filter by ISO 8601 TimeStamp inclusive (defaults to UTC) (optional)
     * @param  string $datetime_filter Specifies field that &#x60;since&#x60; and &#x60;until&#x60; parameters are applied against (optional, default to updated)
     * @param  string[] $tags Filter items matching any tag provided (not all) (optional)
     * @param  string $filter Optional string which filters results by a specified field (described by filterBy). (optional)
     * @param  string $filter_by Optional enum parameter for specifying the field on which to run the filter. (optional, default to course_id)
     * @param  string $order_by Optional enum parameter for specifying the field and order by which to sort the results. (optional, default to created_desc)
     * @param  string $more Pagination token returned as &#x60;more&#x60; property of multi page list requests (optional)
     * @param  bool $include_course_metadata Include course metadata in the results. If the course has no metadata, adding this parameter has no effect. (optional, default to false)
     * @param  bool $include_registration_count Include the registration count in the results (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getCoursesRequest($since = null, $until = null, $datetime_filter = 'updated', $tags = null, $filter = null, $filter_by = 'course_id', $order_by = 'created_desc', $more = null, $include_course_metadata = 'false', $include_registration_count = 'false')
    {

        $resourcePath = '/courses';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($since !== null) {
            $queryParams['since'] = ObjectSerializer::toQueryValue($since);
        }
        // query params
        if ($until !== null) {
            $queryParams['until'] = ObjectSerializer::toQueryValue($until);
        }
        // query params
        if ($datetime_filter !== null) {
            $queryParams['datetimeFilter'] = ObjectSerializer::toQueryValue($datetime_filter);
        }
        // query params
        if (is_array($tags)) {
            $queryParams['tags'] = $tags;
        } else
        if ($tags !== null) {
            $queryParams['tags'] = ObjectSerializer::toQueryValue($tags);
        }
        // query params
        if ($filter !== null) {
            $queryParams['filter'] = ObjectSerializer::toQueryValue($filter);
        }
        // query params
        if ($filter_by !== null) {
            $queryParams['filterBy'] = ObjectSerializer::toQueryValue($filter_by);
        }
        // query params
        if ($order_by !== null) {
            $queryParams['orderBy'] = ObjectSerializer::toQueryValue($order_by);
        }
        // query params
        if ($more !== null) {
            $queryParams['more'] = ObjectSerializer::toQueryValue($more);
        }
        // query params
        if ($include_course_metadata !== null) {
            $queryParams['includeCourseMetadata'] = ObjectSerializer::toQueryValue($include_course_metadata);
        }
        // query params
        if ($include_registration_count !== null) {
            $queryParams['includeRegistrationCount'] = ObjectSerializer::toQueryValue($include_registration_count);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;

            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getImportJobStatus
     *
     * Get import job status for a Course
     *
     * @param  string $import_job_id Id received when the import job was submitted to the importJobs resource. (required)
     *
     * @throws \RusticiSoftware\Cloud\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \RusticiSoftware\Cloud\V2\Model\ImportJobResultSchema
     */
    public function getImportJobStatus($import_job_id)
    {
        list($response) = $this->getImportJobStatusWithHttpInfo($import_job_id);
        return $response;
    }

    /**
     * Operation getImportJobStatusWithHttpInfo
     *
     * Get import job status for a Course
     *
     * @param  string $import_job_id Id received when the import job was submitted to the importJobs resource. (required)
     *
     * @throws \RusticiSoftware\Cloud\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \RusticiSoftware\Cloud\V2\Model\ImportJobResultSchema, HTTP status code, HTTP response headers (array of strings)
     */
    public function getImportJobStatusWithHttpInfo($import_job_id)
    {
        $returnType = '\RusticiSoftware\Cloud\V2\Model\ImportJobResultSchema';
        $request = $this->getImportJobStatusRequest($import_job_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Cloud\V2\Model\ImportJobResultSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Cloud\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Cloud\V2\Model\ResponseError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getImportJobStatusAsync
     *
     * Get import job status for a Course
     *
     * @param  string $import_job_id Id received when the import job was submitted to the importJobs resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getImportJobStatusAsync($import_job_id)
    {
        return $this->getImportJobStatusAsyncWithHttpInfo($import_job_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getImportJobStatusAsyncWithHttpInfo
     *
     * Get import job status for a Course
     *
     * @param  string $import_job_id Id received when the import job was submitted to the importJobs resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getImportJobStatusAsyncWithHttpInfo($import_job_id)
    {
        $returnType = '\RusticiSoftware\Cloud\V2\Model\ImportJobResultSchema';
        $request = $this->getImportJobStatusRequest($import_job_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getImportJobStatus'
     *
     * @param  string $import_job_id Id received when the import job was submitted to the importJobs resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getImportJobStatusRequest($import_job_id)
    {
        // verify the required parameter 'import_job_id' is set
        if ($import_job_id === null || (is_array($import_job_id) && count($import_job_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $import_job_id when calling getImportJobStatus'
            );
        }

        $resourcePath = '/courses/importJobs/{importJobId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($import_job_id !== null) {
            $resourcePath = str_replace(
                '{' . 'importJobId' . '}',
                ObjectSerializer::toPathValue($import_job_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;

            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation importCourseAssetFile
     *
     * Import an asset file for a Course
     *
     * @param  string $course_id course_id (required)
     * @param  \RusticiSoftware\Cloud\V2\Model\ImportAssetRequestSchema $asset_schema asset_schema (required)
     * @param  string $update_asset_policy Describes how SCORM Cloud should handle importing asset files with respect to overwriting files. Valid values are &#39;reject&#39;, &#39;strict&#39;, and &#39;lax&#39;. A &#39;reject&#39; policy request will fail if the asset file already exists on the system (&#39;overwriting&#39; not allowed). A &#39;strict&#39; policy request will fail if the asset file does not already exist (&#39;overwriting&#39; is required). A &#39;lax&#39; policy request will not consider whether the file already exists (i.e., it will attempt to import in all cases). (optional, default to lax)
     *
     * @throws \RusticiSoftware\Cloud\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \RusticiSoftware\Cloud\V2\Model\AssetFileSchema
     */
    public function importCourseAssetFile($course_id, $asset_schema, $update_asset_policy = 'lax')
    {
        list($response) = $this->importCourseAssetFileWithHttpInfo($course_id, $asset_schema, $update_asset_policy);
        return $response;
    }

    /**
     * Operation importCourseAssetFileWithHttpInfo
     *
     * Import an asset file for a Course
     *
     * @param  string $course_id (required)
     * @param  \RusticiSoftware\Cloud\V2\Model\ImportAssetRequestSchema $asset_schema (required)
     * @param  string $update_asset_policy Describes how SCORM Cloud should handle importing asset files with respect to overwriting files. Valid values are &#39;reject&#39;, &#39;strict&#39;, and &#39;lax&#39;. A &#39;reject&#39; policy request will fail if the asset file already exists on the system (&#39;overwriting&#39; not allowed). A &#39;strict&#39; policy request will fail if the asset file does not already exist (&#39;overwriting&#39; is required). A &#39;lax&#39; policy request will not consider whether the file already exists (i.e., it will attempt to import in all cases). (optional, default to lax)
     *
     * @throws \RusticiSoftware\Cloud\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \RusticiSoftware\Cloud\V2\Model\AssetFileSchema, HTTP status code, HTTP response headers (array of strings)
     */
    public function importCourseAssetFileWithHttpInfo($course_id, $asset_schema, $update_asset_policy = 'lax')
    {
        $returnType = '\RusticiSoftware\Cloud\V2\Model\AssetFileSchema';
        $request = $this->importCourseAssetFileRequest($course_id, $asset_schema, $update_asset_policy);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Cloud\V2\Model\AssetFileSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Cloud\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Cloud\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation importCourseAssetFileAsync
     *
     * Import an asset file for a Course
     *
     * @param  string $course_id (required)
     * @param  \RusticiSoftware\Cloud\V2\Model\ImportAssetRequestSchema $asset_schema (required)
     * @param  string $update_asset_policy Describes how SCORM Cloud should handle importing asset files with respect to overwriting files. Valid values are &#39;reject&#39;, &#39;strict&#39;, and &#39;lax&#39;. A &#39;reject&#39; policy request will fail if the asset file already exists on the system (&#39;overwriting&#39; not allowed). A &#39;strict&#39; policy request will fail if the asset file does not already exist (&#39;overwriting&#39; is required). A &#39;lax&#39; policy request will not consider whether the file already exists (i.e., it will attempt to import in all cases). (optional, default to lax)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function importCourseAssetFileAsync($course_id, $asset_schema, $update_asset_policy = 'lax')
    {
        return $this->importCourseAssetFileAsyncWithHttpInfo($course_id, $asset_schema, $update_asset_policy)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation importCourseAssetFileAsyncWithHttpInfo
     *
     * Import an asset file for a Course
     *
     * @param  string $course_id (required)
     * @param  \RusticiSoftware\Cloud\V2\Model\ImportAssetRequestSchema $asset_schema (required)
     * @param  string $update_asset_policy Describes how SCORM Cloud should handle importing asset files with respect to overwriting files. Valid values are &#39;reject&#39;, &#39;strict&#39;, and &#39;lax&#39;. A &#39;reject&#39; policy request will fail if the asset file already exists on the system (&#39;overwriting&#39; not allowed). A &#39;strict&#39; policy request will fail if the asset file does not already exist (&#39;overwriting&#39; is required). A &#39;lax&#39; policy request will not consider whether the file already exists (i.e., it will attempt to import in all cases). (optional, default to lax)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function importCourseAssetFileAsyncWithHttpInfo($course_id, $asset_schema, $update_asset_policy = 'lax')
    {
        $returnType = '\RusticiSoftware\Cloud\V2\Model\AssetFileSchema';
        $request = $this->importCourseAssetFileRequest($course_id, $asset_schema, $update_asset_policy);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'importCourseAssetFile'
     *
     * @param  string $course_id (required)
     * @param  \RusticiSoftware\Cloud\V2\Model\ImportAssetRequestSchema $asset_schema (required)
     * @param  string $update_asset_policy Describes how SCORM Cloud should handle importing asset files with respect to overwriting files. Valid values are &#39;reject&#39;, &#39;strict&#39;, and &#39;lax&#39;. A &#39;reject&#39; policy request will fail if the asset file already exists on the system (&#39;overwriting&#39; not allowed). A &#39;strict&#39; policy request will fail if the asset file does not already exist (&#39;overwriting&#39; is required). A &#39;lax&#39; policy request will not consider whether the file already exists (i.e., it will attempt to import in all cases). (optional, default to lax)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function importCourseAssetFileRequest($course_id, $asset_schema, $update_asset_policy = 'lax')
    {
        // verify the required parameter 'course_id' is set
        if ($course_id === null || (is_array($course_id) && count($course_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $course_id when calling importCourseAssetFile'
            );
        }
        // verify the required parameter 'asset_schema' is set
        if ($asset_schema === null || (is_array($asset_schema) && count($asset_schema) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $asset_schema when calling importCourseAssetFile'
            );
        }

        $resourcePath = '/courses/{courseId}/asset';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($update_asset_policy !== null) {
            $queryParams['updateAssetPolicy'] = ObjectSerializer::toQueryValue($update_asset_policy);
        }

        // path params
        if ($course_id !== null) {
            $resourcePath = str_replace(
                '{' . 'courseId' . '}',
                ObjectSerializer::toPathValue($course_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($asset_schema)) {
            $_tempBody = $asset_schema;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;

            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation importCourseVersionAssetFile
     *
     * Import an asset file for a Course Version
     *
     * @param  string $course_id course_id (required)
     * @param  int $version_id version_id (required)
     * @param  \RusticiSoftware\Cloud\V2\Model\ImportAssetRequestSchema $asset_schema asset_schema (required)
     * @param  string $update_asset_policy Describes how SCORM Cloud should handle importing asset files with respect to overwriting files. Valid values are &#39;reject&#39;, &#39;strict&#39;, and &#39;lax&#39;. A &#39;reject&#39; policy request will fail if the asset file already exists on the system (&#39;overwriting&#39; not allowed). A &#39;strict&#39; policy request will fail if the asset file does not already exist (&#39;overwriting&#39; is required). A &#39;lax&#39; policy request will not consider whether the file already exists (i.e., it will attempt to import in all cases). (optional, default to lax)
     *
     * @throws \RusticiSoftware\Cloud\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \RusticiSoftware\Cloud\V2\Model\AssetFileSchema
     */
    public function importCourseVersionAssetFile($course_id, $version_id, $asset_schema, $update_asset_policy = 'lax')
    {
        list($response) = $this->importCourseVersionAssetFileWithHttpInfo($course_id, $version_id, $asset_schema, $update_asset_policy);
        return $response;
    }

    /**
     * Operation importCourseVersionAssetFileWithHttpInfo
     *
     * Import an asset file for a Course Version
     *
     * @param  string $course_id (required)
     * @param  int $version_id (required)
     * @param  \RusticiSoftware\Cloud\V2\Model\ImportAssetRequestSchema $asset_schema (required)
     * @param  string $update_asset_policy Describes how SCORM Cloud should handle importing asset files with respect to overwriting files. Valid values are &#39;reject&#39;, &#39;strict&#39;, and &#39;lax&#39;. A &#39;reject&#39; policy request will fail if the asset file already exists on the system (&#39;overwriting&#39; not allowed). A &#39;strict&#39; policy request will fail if the asset file does not already exist (&#39;overwriting&#39; is required). A &#39;lax&#39; policy request will not consider whether the file already exists (i.e., it will attempt to import in all cases). (optional, default to lax)
     *
     * @throws \RusticiSoftware\Cloud\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \RusticiSoftware\Cloud\V2\Model\AssetFileSchema, HTTP status code, HTTP response headers (array of strings)
     */
    public function importCourseVersionAssetFileWithHttpInfo($course_id, $version_id, $asset_schema, $update_asset_policy = 'lax')
    {
        $returnType = '\RusticiSoftware\Cloud\V2\Model\AssetFileSchema';
        $request = $this->importCourseVersionAssetFileRequest($course_id, $version_id, $asset_schema, $update_asset_policy);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Cloud\V2\Model\AssetFileSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Cloud\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Cloud\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation importCourseVersionAssetFileAsync
     *
     * Import an asset file for a Course Version
     *
     * @param  string $course_id (required)
     * @param  int $version_id (required)
     * @param  \RusticiSoftware\Cloud\V2\Model\ImportAssetRequestSchema $asset_schema (required)
     * @param  string $update_asset_policy Describes how SCORM Cloud should handle importing asset files with respect to overwriting files. Valid values are &#39;reject&#39;, &#39;strict&#39;, and &#39;lax&#39;. A &#39;reject&#39; policy request will fail if the asset file already exists on the system (&#39;overwriting&#39; not allowed). A &#39;strict&#39; policy request will fail if the asset file does not already exist (&#39;overwriting&#39; is required). A &#39;lax&#39; policy request will not consider whether the file already exists (i.e., it will attempt to import in all cases). (optional, default to lax)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function importCourseVersionAssetFileAsync($course_id, $version_id, $asset_schema, $update_asset_policy = 'lax')
    {
        return $this->importCourseVersionAssetFileAsyncWithHttpInfo($course_id, $version_id, $asset_schema, $update_asset_policy)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation importCourseVersionAssetFileAsyncWithHttpInfo
     *
     * Import an asset file for a Course Version
     *
     * @param  string $course_id (required)
     * @param  int $version_id (required)
     * @param  \RusticiSoftware\Cloud\V2\Model\ImportAssetRequestSchema $asset_schema (required)
     * @param  string $update_asset_policy Describes how SCORM Cloud should handle importing asset files with respect to overwriting files. Valid values are &#39;reject&#39;, &#39;strict&#39;, and &#39;lax&#39;. A &#39;reject&#39; policy request will fail if the asset file already exists on the system (&#39;overwriting&#39; not allowed). A &#39;strict&#39; policy request will fail if the asset file does not already exist (&#39;overwriting&#39; is required). A &#39;lax&#39; policy request will not consider whether the file already exists (i.e., it will attempt to import in all cases). (optional, default to lax)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function importCourseVersionAssetFileAsyncWithHttpInfo($course_id, $version_id, $asset_schema, $update_asset_policy = 'lax')
    {
        $returnType = '\RusticiSoftware\Cloud\V2\Model\AssetFileSchema';
        $request = $this->importCourseVersionAssetFileRequest($course_id, $version_id, $asset_schema, $update_asset_policy);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'importCourseVersionAssetFile'
     *
     * @param  string $course_id (required)
     * @param  int $version_id (required)
     * @param  \RusticiSoftware\Cloud\V2\Model\ImportAssetRequestSchema $asset_schema (required)
     * @param  string $update_asset_policy Describes how SCORM Cloud should handle importing asset files with respect to overwriting files. Valid values are &#39;reject&#39;, &#39;strict&#39;, and &#39;lax&#39;. A &#39;reject&#39; policy request will fail if the asset file already exists on the system (&#39;overwriting&#39; not allowed). A &#39;strict&#39; policy request will fail if the asset file does not already exist (&#39;overwriting&#39; is required). A &#39;lax&#39; policy request will not consider whether the file already exists (i.e., it will attempt to import in all cases). (optional, default to lax)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function importCourseVersionAssetFileRequest($course_id, $version_id, $asset_schema, $update_asset_policy = 'lax')
    {
        // verify the required parameter 'course_id' is set
        if ($course_id === null || (is_array($course_id) && count($course_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $course_id when calling importCourseVersionAssetFile'
            );
        }
        // verify the required parameter 'version_id' is set
        if ($version_id === null || (is_array($version_id) && count($version_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version_id when calling importCourseVersionAssetFile'
            );
        }
        // verify the required parameter 'asset_schema' is set
        if ($asset_schema === null || (is_array($asset_schema) && count($asset_schema) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $asset_schema when calling importCourseVersionAssetFile'
            );
        }

        $resourcePath = '/courses/{courseId}/versions/{versionId}/asset';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($update_asset_policy !== null) {
            $queryParams['updateAssetPolicy'] = ObjectSerializer::toQueryValue($update_asset_policy);
        }

        // path params
        if ($course_id !== null) {
            $resourcePath = str_replace(
                '{' . 'courseId' . '}',
                ObjectSerializer::toPathValue($course_id),
                $resourcePath
            );
        }
        // path params
        if ($version_id !== null) {
            $resourcePath = str_replace(
                '{' . 'versionId' . '}',
                ObjectSerializer::toPathValue($version_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($asset_schema)) {
            $_tempBody = $asset_schema;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;

            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putCourseTags
     *
     * Add tags to a Course
     *
     * @param  string $course_id course_id (required)
     * @param  \RusticiSoftware\Cloud\V2\Model\TagListSchema $tags tags (required)
     *
     * @throws \RusticiSoftware\Cloud\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function putCourseTags($course_id, $tags)
    {
        $this->putCourseTagsWithHttpInfo($course_id, $tags);
    }

    /**
     * Operation putCourseTagsWithHttpInfo
     *
     * Add tags to a Course
     *
     * @param  string $course_id (required)
     * @param  \RusticiSoftware\Cloud\V2\Model\TagListSchema $tags (required)
     *
     * @throws \RusticiSoftware\Cloud\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function putCourseTagsWithHttpInfo($course_id, $tags)
    {
        $returnType = '';
        $request = $this->putCourseTagsRequest($course_id, $tags);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Cloud\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Cloud\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putCourseTagsAsync
     *
     * Add tags to a Course
     *
     * @param  string $course_id (required)
     * @param  \RusticiSoftware\Cloud\V2\Model\TagListSchema $tags (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putCourseTagsAsync($course_id, $tags)
    {
        return $this->putCourseTagsAsyncWithHttpInfo($course_id, $tags)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putCourseTagsAsyncWithHttpInfo
     *
     * Add tags to a Course
     *
     * @param  string $course_id (required)
     * @param  \RusticiSoftware\Cloud\V2\Model\TagListSchema $tags (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putCourseTagsAsyncWithHttpInfo($course_id, $tags)
    {
        $returnType = '';
        $request = $this->putCourseTagsRequest($course_id, $tags);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putCourseTags'
     *
     * @param  string $course_id (required)
     * @param  \RusticiSoftware\Cloud\V2\Model\TagListSchema $tags (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putCourseTagsRequest($course_id, $tags)
    {
        // verify the required parameter 'course_id' is set
        if ($course_id === null || (is_array($course_id) && count($course_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $course_id when calling putCourseTags'
            );
        }
        // verify the required parameter 'tags' is set
        if ($tags === null || (is_array($tags) && count($tags) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $tags when calling putCourseTags'
            );
        }

        $resourcePath = '/courses/{courseId}/tags';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($course_id !== null) {
            $resourcePath = str_replace(
                '{' . 'courseId' . '}',
                ObjectSerializer::toPathValue($course_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($tags)) {
            $_tempBody = $tags;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;

            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putCourseTagsBatch
     *
     * Add a group of tags to a group of Courses
     *
     * @param  \RusticiSoftware\Cloud\V2\Model\BatchTagsSchema $batch Array of ids, and array of tags for bulk tag operations (required)
     *
     * @throws \RusticiSoftware\Cloud\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function putCourseTagsBatch($batch)
    {
        $this->putCourseTagsBatchWithHttpInfo($batch);
    }

    /**
     * Operation putCourseTagsBatchWithHttpInfo
     *
     * Add a group of tags to a group of Courses
     *
     * @param  \RusticiSoftware\Cloud\V2\Model\BatchTagsSchema $batch Array of ids, and array of tags for bulk tag operations (required)
     *
     * @throws \RusticiSoftware\Cloud\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function putCourseTagsBatchWithHttpInfo($batch)
    {
        $returnType = '';
        $request = $this->putCourseTagsBatchRequest($batch);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Cloud\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Cloud\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putCourseTagsBatchAsync
     *
     * Add a group of tags to a group of Courses
     *
     * @param  \RusticiSoftware\Cloud\V2\Model\BatchTagsSchema $batch Array of ids, and array of tags for bulk tag operations (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putCourseTagsBatchAsync($batch)
    {
        return $this->putCourseTagsBatchAsyncWithHttpInfo($batch)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putCourseTagsBatchAsyncWithHttpInfo
     *
     * Add a group of tags to a group of Courses
     *
     * @param  \RusticiSoftware\Cloud\V2\Model\BatchTagsSchema $batch Array of ids, and array of tags for bulk tag operations (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putCourseTagsBatchAsyncWithHttpInfo($batch)
    {
        $returnType = '';
        $request = $this->putCourseTagsBatchRequest($batch);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putCourseTagsBatch'
     *
     * @param  \RusticiSoftware\Cloud\V2\Model\BatchTagsSchema $batch Array of ids, and array of tags for bulk tag operations (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putCourseTagsBatchRequest($batch)
    {
        // verify the required parameter 'batch' is set
        if ($batch === null || (is_array($batch) && count($batch) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $batch when calling putCourseTagsBatch'
            );
        }

        $resourcePath = '/courses/tags';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($batch)) {
            $_tempBody = $batch;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;

            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation setCourseConfiguration
     *
     * Update configuration settings for a Course
     *
     * @param  string $course_id course_id (required)
     * @param  \RusticiSoftware\Cloud\V2\Model\SettingsPostSchema $configuration_settings configuration_settings (required)
     *
     * @throws \RusticiSoftware\Cloud\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function setCourseConfiguration($course_id, $configuration_settings)
    {
        $this->setCourseConfigurationWithHttpInfo($course_id, $configuration_settings);
    }

    /**
     * Operation setCourseConfigurationWithHttpInfo
     *
     * Update configuration settings for a Course
     *
     * @param  string $course_id (required)
     * @param  \RusticiSoftware\Cloud\V2\Model\SettingsPostSchema $configuration_settings (required)
     *
     * @throws \RusticiSoftware\Cloud\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function setCourseConfigurationWithHttpInfo($course_id, $configuration_settings)
    {
        $returnType = '';
        $request = $this->setCourseConfigurationRequest($course_id, $configuration_settings);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Cloud\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Cloud\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation setCourseConfigurationAsync
     *
     * Update configuration settings for a Course
     *
     * @param  string $course_id (required)
     * @param  \RusticiSoftware\Cloud\V2\Model\SettingsPostSchema $configuration_settings (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setCourseConfigurationAsync($course_id, $configuration_settings)
    {
        return $this->setCourseConfigurationAsyncWithHttpInfo($course_id, $configuration_settings)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation setCourseConfigurationAsyncWithHttpInfo
     *
     * Update configuration settings for a Course
     *
     * @param  string $course_id (required)
     * @param  \RusticiSoftware\Cloud\V2\Model\SettingsPostSchema $configuration_settings (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setCourseConfigurationAsyncWithHttpInfo($course_id, $configuration_settings)
    {
        $returnType = '';
        $request = $this->setCourseConfigurationRequest($course_id, $configuration_settings);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'setCourseConfiguration'
     *
     * @param  string $course_id (required)
     * @param  \RusticiSoftware\Cloud\V2\Model\SettingsPostSchema $configuration_settings (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function setCourseConfigurationRequest($course_id, $configuration_settings)
    {
        // verify the required parameter 'course_id' is set
        if ($course_id === null || (is_array($course_id) && count($course_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $course_id when calling setCourseConfiguration'
            );
        }
        // verify the required parameter 'configuration_settings' is set
        if ($configuration_settings === null || (is_array($configuration_settings) && count($configuration_settings) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $configuration_settings when calling setCourseConfiguration'
            );
        }

        $resourcePath = '/courses/{courseId}/configuration';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($course_id !== null) {
            $resourcePath = str_replace(
                '{' . 'courseId' . '}',
                ObjectSerializer::toPathValue($course_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($configuration_settings)) {
            $_tempBody = $configuration_settings;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;

            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation setCourseTitle
     *
     * Update title for a Course
     *
     * @param  string $course_id course_id (required)
     * @param  \RusticiSoftware\Cloud\V2\Model\TitleSchema $title title (required)
     *
     * @throws \RusticiSoftware\Cloud\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function setCourseTitle($course_id, $title)
    {
        $this->setCourseTitleWithHttpInfo($course_id, $title);
    }

    /**
     * Operation setCourseTitleWithHttpInfo
     *
     * Update title for a Course
     *
     * @param  string $course_id (required)
     * @param  \RusticiSoftware\Cloud\V2\Model\TitleSchema $title (required)
     *
     * @throws \RusticiSoftware\Cloud\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function setCourseTitleWithHttpInfo($course_id, $title)
    {
        $returnType = '';
        $request = $this->setCourseTitleRequest($course_id, $title);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Cloud\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Cloud\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation setCourseTitleAsync
     *
     * Update title for a Course
     *
     * @param  string $course_id (required)
     * @param  \RusticiSoftware\Cloud\V2\Model\TitleSchema $title (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setCourseTitleAsync($course_id, $title)
    {
        return $this->setCourseTitleAsyncWithHttpInfo($course_id, $title)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation setCourseTitleAsyncWithHttpInfo
     *
     * Update title for a Course
     *
     * @param  string $course_id (required)
     * @param  \RusticiSoftware\Cloud\V2\Model\TitleSchema $title (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setCourseTitleAsyncWithHttpInfo($course_id, $title)
    {
        $returnType = '';
        $request = $this->setCourseTitleRequest($course_id, $title);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'setCourseTitle'
     *
     * @param  string $course_id (required)
     * @param  \RusticiSoftware\Cloud\V2\Model\TitleSchema $title (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function setCourseTitleRequest($course_id, $title)
    {
        // verify the required parameter 'course_id' is set
        if ($course_id === null || (is_array($course_id) && count($course_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $course_id when calling setCourseTitle'
            );
        }
        // verify the required parameter 'title' is set
        if ($title === null || (is_array($title) && count($title) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $title when calling setCourseTitle'
            );
        }

        $resourcePath = '/courses/{courseId}/title';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($course_id !== null) {
            $resourcePath = str_replace(
                '{' . 'courseId' . '}',
                ObjectSerializer::toPathValue($course_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($title)) {
            $_tempBody = $title;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;

            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation setCourseVersionConfiguration
     *
     * Update configuration settings for a Course Version
     *
     * @param  string $course_id course_id (required)
     * @param  int $version_id version_id (required)
     * @param  \RusticiSoftware\Cloud\V2\Model\SettingsPostSchema $configuration_settings configuration_settings (required)
     *
     * @throws \RusticiSoftware\Cloud\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function setCourseVersionConfiguration($course_id, $version_id, $configuration_settings)
    {
        $this->setCourseVersionConfigurationWithHttpInfo($course_id, $version_id, $configuration_settings);
    }

    /**
     * Operation setCourseVersionConfigurationWithHttpInfo
     *
     * Update configuration settings for a Course Version
     *
     * @param  string $course_id (required)
     * @param  int $version_id (required)
     * @param  \RusticiSoftware\Cloud\V2\Model\SettingsPostSchema $configuration_settings (required)
     *
     * @throws \RusticiSoftware\Cloud\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function setCourseVersionConfigurationWithHttpInfo($course_id, $version_id, $configuration_settings)
    {
        $returnType = '';
        $request = $this->setCourseVersionConfigurationRequest($course_id, $version_id, $configuration_settings);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Cloud\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Cloud\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation setCourseVersionConfigurationAsync
     *
     * Update configuration settings for a Course Version
     *
     * @param  string $course_id (required)
     * @param  int $version_id (required)
     * @param  \RusticiSoftware\Cloud\V2\Model\SettingsPostSchema $configuration_settings (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setCourseVersionConfigurationAsync($course_id, $version_id, $configuration_settings)
    {
        return $this->setCourseVersionConfigurationAsyncWithHttpInfo($course_id, $version_id, $configuration_settings)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation setCourseVersionConfigurationAsyncWithHttpInfo
     *
     * Update configuration settings for a Course Version
     *
     * @param  string $course_id (required)
     * @param  int $version_id (required)
     * @param  \RusticiSoftware\Cloud\V2\Model\SettingsPostSchema $configuration_settings (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setCourseVersionConfigurationAsyncWithHttpInfo($course_id, $version_id, $configuration_settings)
    {
        $returnType = '';
        $request = $this->setCourseVersionConfigurationRequest($course_id, $version_id, $configuration_settings);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'setCourseVersionConfiguration'
     *
     * @param  string $course_id (required)
     * @param  int $version_id (required)
     * @param  \RusticiSoftware\Cloud\V2\Model\SettingsPostSchema $configuration_settings (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function setCourseVersionConfigurationRequest($course_id, $version_id, $configuration_settings)
    {
        // verify the required parameter 'course_id' is set
        if ($course_id === null || (is_array($course_id) && count($course_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $course_id when calling setCourseVersionConfiguration'
            );
        }
        // verify the required parameter 'version_id' is set
        if ($version_id === null || (is_array($version_id) && count($version_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version_id when calling setCourseVersionConfiguration'
            );
        }
        // verify the required parameter 'configuration_settings' is set
        if ($configuration_settings === null || (is_array($configuration_settings) && count($configuration_settings) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $configuration_settings when calling setCourseVersionConfiguration'
            );
        }

        $resourcePath = '/courses/{courseId}/versions/{versionId}/configuration';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($course_id !== null) {
            $resourcePath = str_replace(
                '{' . 'courseId' . '}',
                ObjectSerializer::toPathValue($course_id),
                $resourcePath
            );
        }
        // path params
        if ($version_id !== null) {
            $resourcePath = str_replace(
                '{' . 'versionId' . '}',
                ObjectSerializer::toPathValue($version_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($configuration_settings)) {
            $_tempBody = $configuration_settings;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;

            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation uploadCourseAssetFile
     *
     * Upload an asset file for a Course
     *
     * @param  string $course_id course_id (required)
     * @param  string $destination Relative path from the course&#39;s base directory where the asset file will be uploaded. &#x60;/Etiquette/Course.html&#x60; will upload the file into the Etiquette folder of the course. (required)
     * @param  \SplFileObject $file The asset file to import into the course. (optional)
     * @param  string $update_asset_policy Describes how SCORM Cloud should handle importing asset files with respect to overwriting files. Valid values are &#39;reject&#39;, &#39;strict&#39;, and &#39;lax&#39;. A &#39;reject&#39; policy request will fail if the asset file already exists on the system (&#39;overwriting&#39; not allowed). A &#39;strict&#39; policy request will fail if the asset file does not already exist (&#39;overwriting&#39; is required). A &#39;lax&#39; policy request will not consider whether the file already exists (i.e., it will attempt to import in all cases). (optional, default to lax)
     *
     * @throws \RusticiSoftware\Cloud\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \RusticiSoftware\Cloud\V2\Model\AssetFileSchema
     */
    public function uploadCourseAssetFile($course_id, $destination, $file = null, $update_asset_policy = 'lax')
    {
        list($response) = $this->uploadCourseAssetFileWithHttpInfo($course_id, $destination, $file, $update_asset_policy);
        return $response;
    }

    /**
     * Operation uploadCourseAssetFileWithHttpInfo
     *
     * Upload an asset file for a Course
     *
     * @param  string $course_id (required)
     * @param  string $destination Relative path from the course&#39;s base directory where the asset file will be uploaded. &#x60;/Etiquette/Course.html&#x60; will upload the file into the Etiquette folder of the course. (required)
     * @param  \SplFileObject $file The asset file to import into the course. (optional)
     * @param  string $update_asset_policy Describes how SCORM Cloud should handle importing asset files with respect to overwriting files. Valid values are &#39;reject&#39;, &#39;strict&#39;, and &#39;lax&#39;. A &#39;reject&#39; policy request will fail if the asset file already exists on the system (&#39;overwriting&#39; not allowed). A &#39;strict&#39; policy request will fail if the asset file does not already exist (&#39;overwriting&#39; is required). A &#39;lax&#39; policy request will not consider whether the file already exists (i.e., it will attempt to import in all cases). (optional, default to lax)
     *
     * @throws \RusticiSoftware\Cloud\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \RusticiSoftware\Cloud\V2\Model\AssetFileSchema, HTTP status code, HTTP response headers (array of strings)
     */
    public function uploadCourseAssetFileWithHttpInfo($course_id, $destination, $file = null, $update_asset_policy = 'lax')
    {
        $returnType = '\RusticiSoftware\Cloud\V2\Model\AssetFileSchema';
        $request = $this->uploadCourseAssetFileRequest($course_id, $destination, $file, $update_asset_policy);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Cloud\V2\Model\AssetFileSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Cloud\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Cloud\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation uploadCourseAssetFileAsync
     *
     * Upload an asset file for a Course
     *
     * @param  string $course_id (required)
     * @param  string $destination Relative path from the course&#39;s base directory where the asset file will be uploaded. &#x60;/Etiquette/Course.html&#x60; will upload the file into the Etiquette folder of the course. (required)
     * @param  \SplFileObject $file The asset file to import into the course. (optional)
     * @param  string $update_asset_policy Describes how SCORM Cloud should handle importing asset files with respect to overwriting files. Valid values are &#39;reject&#39;, &#39;strict&#39;, and &#39;lax&#39;. A &#39;reject&#39; policy request will fail if the asset file already exists on the system (&#39;overwriting&#39; not allowed). A &#39;strict&#39; policy request will fail if the asset file does not already exist (&#39;overwriting&#39; is required). A &#39;lax&#39; policy request will not consider whether the file already exists (i.e., it will attempt to import in all cases). (optional, default to lax)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function uploadCourseAssetFileAsync($course_id, $destination, $file = null, $update_asset_policy = 'lax')
    {
        return $this->uploadCourseAssetFileAsyncWithHttpInfo($course_id, $destination, $file, $update_asset_policy)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation uploadCourseAssetFileAsyncWithHttpInfo
     *
     * Upload an asset file for a Course
     *
     * @param  string $course_id (required)
     * @param  string $destination Relative path from the course&#39;s base directory where the asset file will be uploaded. &#x60;/Etiquette/Course.html&#x60; will upload the file into the Etiquette folder of the course. (required)
     * @param  \SplFileObject $file The asset file to import into the course. (optional)
     * @param  string $update_asset_policy Describes how SCORM Cloud should handle importing asset files with respect to overwriting files. Valid values are &#39;reject&#39;, &#39;strict&#39;, and &#39;lax&#39;. A &#39;reject&#39; policy request will fail if the asset file already exists on the system (&#39;overwriting&#39; not allowed). A &#39;strict&#39; policy request will fail if the asset file does not already exist (&#39;overwriting&#39; is required). A &#39;lax&#39; policy request will not consider whether the file already exists (i.e., it will attempt to import in all cases). (optional, default to lax)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function uploadCourseAssetFileAsyncWithHttpInfo($course_id, $destination, $file = null, $update_asset_policy = 'lax')
    {
        $returnType = '\RusticiSoftware\Cloud\V2\Model\AssetFileSchema';
        $request = $this->uploadCourseAssetFileRequest($course_id, $destination, $file, $update_asset_policy);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'uploadCourseAssetFile'
     *
     * @param  string $course_id (required)
     * @param  string $destination Relative path from the course&#39;s base directory where the asset file will be uploaded. &#x60;/Etiquette/Course.html&#x60; will upload the file into the Etiquette folder of the course. (required)
     * @param  \SplFileObject $file The asset file to import into the course. (optional)
     * @param  string $update_asset_policy Describes how SCORM Cloud should handle importing asset files with respect to overwriting files. Valid values are &#39;reject&#39;, &#39;strict&#39;, and &#39;lax&#39;. A &#39;reject&#39; policy request will fail if the asset file already exists on the system (&#39;overwriting&#39; not allowed). A &#39;strict&#39; policy request will fail if the asset file does not already exist (&#39;overwriting&#39; is required). A &#39;lax&#39; policy request will not consider whether the file already exists (i.e., it will attempt to import in all cases). (optional, default to lax)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function uploadCourseAssetFileRequest($course_id, $destination, $file = null, $update_asset_policy = 'lax')
    {
        // verify the required parameter 'course_id' is set
        if ($course_id === null || (is_array($course_id) && count($course_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $course_id when calling uploadCourseAssetFile'
            );
        }
        // verify the required parameter 'destination' is set
        if ($destination === null || (is_array($destination) && count($destination) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $destination when calling uploadCourseAssetFile'
            );
        }

        $resourcePath = '/courses/{courseId}/asset/upload';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($update_asset_policy !== null) {
            $queryParams['updateAssetPolicy'] = ObjectSerializer::toQueryValue($update_asset_policy);
        }

        // path params
        if ($course_id !== null) {
            $resourcePath = str_replace(
                '{' . 'courseId' . '}',
                ObjectSerializer::toPathValue($course_id),
                $resourcePath
            );
        }

        // form params
        if ($file !== null) {
            $multipart = true;
            $formParams['file'] = \GuzzleHttp\Psr7\Utils::tryFopen(ObjectSerializer::toFormValue($file), 'rb');
        }
        // form params
        if ($destination !== null) {
            $formParams['destination'] = ObjectSerializer::toFormValue($destination);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['multipart/form-data']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;

            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation uploadCourseVersionAssetFile
     *
     * Upload an asset file for Course Version
     *
     * @param  string $course_id course_id (required)
     * @param  int $version_id version_id (required)
     * @param  string $destination Relative path from the course&#39;s base directory where the asset file will be uploaded. &#x60;/Etiquette/Course.html&#x60; will upload the file into the Etiquette folder of the course. (required)
     * @param  \SplFileObject $file The asset file to import into the course. (optional)
     * @param  string $update_asset_policy Describes how SCORM Cloud should handle importing asset files with respect to overwriting files. Valid values are &#39;reject&#39;, &#39;strict&#39;, and &#39;lax&#39;. A &#39;reject&#39; policy request will fail if the asset file already exists on the system (&#39;overwriting&#39; not allowed). A &#39;strict&#39; policy request will fail if the asset file does not already exist (&#39;overwriting&#39; is required). A &#39;lax&#39; policy request will not consider whether the file already exists (i.e., it will attempt to import in all cases). (optional, default to lax)
     *
     * @throws \RusticiSoftware\Cloud\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \RusticiSoftware\Cloud\V2\Model\AssetFileSchema
     */
    public function uploadCourseVersionAssetFile($course_id, $version_id, $destination, $file = null, $update_asset_policy = 'lax')
    {
        list($response) = $this->uploadCourseVersionAssetFileWithHttpInfo($course_id, $version_id, $destination, $file, $update_asset_policy);
        return $response;
    }

    /**
     * Operation uploadCourseVersionAssetFileWithHttpInfo
     *
     * Upload an asset file for Course Version
     *
     * @param  string $course_id (required)
     * @param  int $version_id (required)
     * @param  string $destination Relative path from the course&#39;s base directory where the asset file will be uploaded. &#x60;/Etiquette/Course.html&#x60; will upload the file into the Etiquette folder of the course. (required)
     * @param  \SplFileObject $file The asset file to import into the course. (optional)
     * @param  string $update_asset_policy Describes how SCORM Cloud should handle importing asset files with respect to overwriting files. Valid values are &#39;reject&#39;, &#39;strict&#39;, and &#39;lax&#39;. A &#39;reject&#39; policy request will fail if the asset file already exists on the system (&#39;overwriting&#39; not allowed). A &#39;strict&#39; policy request will fail if the asset file does not already exist (&#39;overwriting&#39; is required). A &#39;lax&#39; policy request will not consider whether the file already exists (i.e., it will attempt to import in all cases). (optional, default to lax)
     *
     * @throws \RusticiSoftware\Cloud\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \RusticiSoftware\Cloud\V2\Model\AssetFileSchema, HTTP status code, HTTP response headers (array of strings)
     */
    public function uploadCourseVersionAssetFileWithHttpInfo($course_id, $version_id, $destination, $file = null, $update_asset_policy = 'lax')
    {
        $returnType = '\RusticiSoftware\Cloud\V2\Model\AssetFileSchema';
        $request = $this->uploadCourseVersionAssetFileRequest($course_id, $version_id, $destination, $file, $update_asset_policy);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Cloud\V2\Model\AssetFileSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Cloud\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Cloud\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation uploadCourseVersionAssetFileAsync
     *
     * Upload an asset file for Course Version
     *
     * @param  string $course_id (required)
     * @param  int $version_id (required)
     * @param  string $destination Relative path from the course&#39;s base directory where the asset file will be uploaded. &#x60;/Etiquette/Course.html&#x60; will upload the file into the Etiquette folder of the course. (required)
     * @param  \SplFileObject $file The asset file to import into the course. (optional)
     * @param  string $update_asset_policy Describes how SCORM Cloud should handle importing asset files with respect to overwriting files. Valid values are &#39;reject&#39;, &#39;strict&#39;, and &#39;lax&#39;. A &#39;reject&#39; policy request will fail if the asset file already exists on the system (&#39;overwriting&#39; not allowed). A &#39;strict&#39; policy request will fail if the asset file does not already exist (&#39;overwriting&#39; is required). A &#39;lax&#39; policy request will not consider whether the file already exists (i.e., it will attempt to import in all cases). (optional, default to lax)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function uploadCourseVersionAssetFileAsync($course_id, $version_id, $destination, $file = null, $update_asset_policy = 'lax')
    {
        return $this->uploadCourseVersionAssetFileAsyncWithHttpInfo($course_id, $version_id, $destination, $file, $update_asset_policy)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation uploadCourseVersionAssetFileAsyncWithHttpInfo
     *
     * Upload an asset file for Course Version
     *
     * @param  string $course_id (required)
     * @param  int $version_id (required)
     * @param  string $destination Relative path from the course&#39;s base directory where the asset file will be uploaded. &#x60;/Etiquette/Course.html&#x60; will upload the file into the Etiquette folder of the course. (required)
     * @param  \SplFileObject $file The asset file to import into the course. (optional)
     * @param  string $update_asset_policy Describes how SCORM Cloud should handle importing asset files with respect to overwriting files. Valid values are &#39;reject&#39;, &#39;strict&#39;, and &#39;lax&#39;. A &#39;reject&#39; policy request will fail if the asset file already exists on the system (&#39;overwriting&#39; not allowed). A &#39;strict&#39; policy request will fail if the asset file does not already exist (&#39;overwriting&#39; is required). A &#39;lax&#39; policy request will not consider whether the file already exists (i.e., it will attempt to import in all cases). (optional, default to lax)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function uploadCourseVersionAssetFileAsyncWithHttpInfo($course_id, $version_id, $destination, $file = null, $update_asset_policy = 'lax')
    {
        $returnType = '\RusticiSoftware\Cloud\V2\Model\AssetFileSchema';
        $request = $this->uploadCourseVersionAssetFileRequest($course_id, $version_id, $destination, $file, $update_asset_policy);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'uploadCourseVersionAssetFile'
     *
     * @param  string $course_id (required)
     * @param  int $version_id (required)
     * @param  string $destination Relative path from the course&#39;s base directory where the asset file will be uploaded. &#x60;/Etiquette/Course.html&#x60; will upload the file into the Etiquette folder of the course. (required)
     * @param  \SplFileObject $file The asset file to import into the course. (optional)
     * @param  string $update_asset_policy Describes how SCORM Cloud should handle importing asset files with respect to overwriting files. Valid values are &#39;reject&#39;, &#39;strict&#39;, and &#39;lax&#39;. A &#39;reject&#39; policy request will fail if the asset file already exists on the system (&#39;overwriting&#39; not allowed). A &#39;strict&#39; policy request will fail if the asset file does not already exist (&#39;overwriting&#39; is required). A &#39;lax&#39; policy request will not consider whether the file already exists (i.e., it will attempt to import in all cases). (optional, default to lax)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function uploadCourseVersionAssetFileRequest($course_id, $version_id, $destination, $file = null, $update_asset_policy = 'lax')
    {
        // verify the required parameter 'course_id' is set
        if ($course_id === null || (is_array($course_id) && count($course_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $course_id when calling uploadCourseVersionAssetFile'
            );
        }
        // verify the required parameter 'version_id' is set
        if ($version_id === null || (is_array($version_id) && count($version_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version_id when calling uploadCourseVersionAssetFile'
            );
        }
        // verify the required parameter 'destination' is set
        if ($destination === null || (is_array($destination) && count($destination) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $destination when calling uploadCourseVersionAssetFile'
            );
        }

        $resourcePath = '/courses/{courseId}/versions/{versionId}/asset/upload';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($update_asset_policy !== null) {
            $queryParams['updateAssetPolicy'] = ObjectSerializer::toQueryValue($update_asset_policy);
        }

        // path params
        if ($course_id !== null) {
            $resourcePath = str_replace(
                '{' . 'courseId' . '}',
                ObjectSerializer::toPathValue($course_id),
                $resourcePath
            );
        }
        // path params
        if ($version_id !== null) {
            $resourcePath = str_replace(
                '{' . 'versionId' . '}',
                ObjectSerializer::toPathValue($version_id),
                $resourcePath
            );
        }

        // form params
        if ($file !== null) {
            $multipart = true;
            $formParams['file'] = \GuzzleHttp\Psr7\Utils::tryFopen(ObjectSerializer::toFormValue($file), 'rb');
        }
        // form params
        if ($destination !== null) {
            $formParams['destination'] = ObjectSerializer::toFormValue($destination);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['multipart/form-data']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;

            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
