<?php
/**
 * CourseApi
 * PHP version 5
 *
 * @category Class
 * @package  RusticiSoftware\Cloud\V2
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * SCORM Cloud Rest API
 *
 * REST API used for SCORM Cloud integrations.
 *
 * OpenAPI spec version: 2.0
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 2.4.12
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace RusticiSoftware\Cloud\V2\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use RusticiSoftware\Cloud\V2\ApiException;
use RusticiSoftware\Cloud\V2\Configuration;
use RusticiSoftware\Cloud\V2\HeaderSelector;
use RusticiSoftware\Cloud\V2\ObjectSerializer;

/**
 * CourseApi Class Doc Comment
 *
 * @category Class
 * @package  RusticiSoftware\Cloud\V2
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class CourseApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation buildCoursePreviewLaunchLink
     *
     * Get a link to preview a course.
     *
     * @param  string $course_id course_id (required)
     * @param  \RusticiSoftware\Cloud\V2\Model\LaunchLinkRequestSchema $launch_link_request launch_link_request (required)
     * @param  string $css_url css_url (optional)
     *
     * @throws \RusticiSoftware\Cloud\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \RusticiSoftware\Cloud\V2\Model\LaunchLinkSchema
     */
    public function buildCoursePreviewLaunchLink($course_id, $launch_link_request, $css_url = null)
    {
        list($response) = $this->buildCoursePreviewLaunchLinkWithHttpInfo($course_id, $launch_link_request, $css_url);
        return $response;
    }

    /**
     * Operation buildCoursePreviewLaunchLinkWithHttpInfo
     *
     * Get a link to preview a course.
     *
     * @param  string $course_id (required)
     * @param  \RusticiSoftware\Cloud\V2\Model\LaunchLinkRequestSchema $launch_link_request (required)
     * @param  string $css_url (optional)
     *
     * @throws \RusticiSoftware\Cloud\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \RusticiSoftware\Cloud\V2\Model\LaunchLinkSchema, HTTP status code, HTTP response headers (array of strings)
     */
    public function buildCoursePreviewLaunchLinkWithHttpInfo($course_id, $launch_link_request, $css_url = null)
    {
        $returnType = '\RusticiSoftware\Cloud\V2\Model\LaunchLinkSchema';
        $request = $this->buildCoursePreviewLaunchLinkRequest($course_id, $launch_link_request, $css_url);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Cloud\V2\Model\LaunchLinkSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Cloud\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Cloud\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation buildCoursePreviewLaunchLinkAsync
     *
     * Get a link to preview a course.
     *
     * @param  string $course_id (required)
     * @param  \RusticiSoftware\Cloud\V2\Model\LaunchLinkRequestSchema $launch_link_request (required)
     * @param  string $css_url (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function buildCoursePreviewLaunchLinkAsync($course_id, $launch_link_request, $css_url = null)
    {
        return $this->buildCoursePreviewLaunchLinkAsyncWithHttpInfo($course_id, $launch_link_request, $css_url)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation buildCoursePreviewLaunchLinkAsyncWithHttpInfo
     *
     * Get a link to preview a course.
     *
     * @param  string $course_id (required)
     * @param  \RusticiSoftware\Cloud\V2\Model\LaunchLinkRequestSchema $launch_link_request (required)
     * @param  string $css_url (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function buildCoursePreviewLaunchLinkAsyncWithHttpInfo($course_id, $launch_link_request, $css_url = null)
    {
        $returnType = '\RusticiSoftware\Cloud\V2\Model\LaunchLinkSchema';
        $request = $this->buildCoursePreviewLaunchLinkRequest($course_id, $launch_link_request, $css_url);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'buildCoursePreviewLaunchLink'
     *
     * @param  string $course_id (required)
     * @param  \RusticiSoftware\Cloud\V2\Model\LaunchLinkRequestSchema $launch_link_request (required)
     * @param  string $css_url (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function buildCoursePreviewLaunchLinkRequest($course_id, $launch_link_request, $css_url = null)
    {
        // verify the required parameter 'course_id' is set
        if ($course_id === null || (is_array($course_id) && count($course_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $course_id when calling buildCoursePreviewLaunchLink'
            );
        }
        // verify the required parameter 'launch_link_request' is set
        if ($launch_link_request === null || (is_array($launch_link_request) && count($launch_link_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $launch_link_request when calling buildCoursePreviewLaunchLink'
            );
        }

        $resourcePath = '/courses/{courseId}/preview';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($css_url !== null) {
            $queryParams['cssUrl'] = ObjectSerializer::toQueryValue($css_url);
        }

        // path params
        if ($course_id !== null) {
            $resourcePath = str_replace(
                '{' . 'courseId' . '}',
                ObjectSerializer::toPathValue($course_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($launch_link_request)) {
            $_tempBody = $launch_link_request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation buildCoursePreviewLaunchLinkWithVersion
     *
     * Get a link to preview a particular course version.
     *
     * @param  string $course_id course_id (required)
     * @param  int $version_id The course version (required)
     * @param  \RusticiSoftware\Cloud\V2\Model\LaunchLinkRequestSchema $launch_link_request launch_link_request (required)
     *
     * @throws \RusticiSoftware\Cloud\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \RusticiSoftware\Cloud\V2\Model\LaunchLinkSchema
     */
    public function buildCoursePreviewLaunchLinkWithVersion($course_id, $version_id, $launch_link_request)
    {
        list($response) = $this->buildCoursePreviewLaunchLinkWithVersionWithHttpInfo($course_id, $version_id, $launch_link_request);
        return $response;
    }

    /**
     * Operation buildCoursePreviewLaunchLinkWithVersionWithHttpInfo
     *
     * Get a link to preview a particular course version.
     *
     * @param  string $course_id (required)
     * @param  int $version_id The course version (required)
     * @param  \RusticiSoftware\Cloud\V2\Model\LaunchLinkRequestSchema $launch_link_request (required)
     *
     * @throws \RusticiSoftware\Cloud\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \RusticiSoftware\Cloud\V2\Model\LaunchLinkSchema, HTTP status code, HTTP response headers (array of strings)
     */
    public function buildCoursePreviewLaunchLinkWithVersionWithHttpInfo($course_id, $version_id, $launch_link_request)
    {
        $returnType = '\RusticiSoftware\Cloud\V2\Model\LaunchLinkSchema';
        $request = $this->buildCoursePreviewLaunchLinkWithVersionRequest($course_id, $version_id, $launch_link_request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Cloud\V2\Model\LaunchLinkSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Cloud\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Cloud\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation buildCoursePreviewLaunchLinkWithVersionAsync
     *
     * Get a link to preview a particular course version.
     *
     * @param  string $course_id (required)
     * @param  int $version_id The course version (required)
     * @param  \RusticiSoftware\Cloud\V2\Model\LaunchLinkRequestSchema $launch_link_request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function buildCoursePreviewLaunchLinkWithVersionAsync($course_id, $version_id, $launch_link_request)
    {
        return $this->buildCoursePreviewLaunchLinkWithVersionAsyncWithHttpInfo($course_id, $version_id, $launch_link_request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation buildCoursePreviewLaunchLinkWithVersionAsyncWithHttpInfo
     *
     * Get a link to preview a particular course version.
     *
     * @param  string $course_id (required)
     * @param  int $version_id The course version (required)
     * @param  \RusticiSoftware\Cloud\V2\Model\LaunchLinkRequestSchema $launch_link_request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function buildCoursePreviewLaunchLinkWithVersionAsyncWithHttpInfo($course_id, $version_id, $launch_link_request)
    {
        $returnType = '\RusticiSoftware\Cloud\V2\Model\LaunchLinkSchema';
        $request = $this->buildCoursePreviewLaunchLinkWithVersionRequest($course_id, $version_id, $launch_link_request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'buildCoursePreviewLaunchLinkWithVersion'
     *
     * @param  string $course_id (required)
     * @param  int $version_id The course version (required)
     * @param  \RusticiSoftware\Cloud\V2\Model\LaunchLinkRequestSchema $launch_link_request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function buildCoursePreviewLaunchLinkWithVersionRequest($course_id, $version_id, $launch_link_request)
    {
        // verify the required parameter 'course_id' is set
        if ($course_id === null || (is_array($course_id) && count($course_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $course_id when calling buildCoursePreviewLaunchLinkWithVersion'
            );
        }
        // verify the required parameter 'version_id' is set
        if ($version_id === null || (is_array($version_id) && count($version_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version_id when calling buildCoursePreviewLaunchLinkWithVersion'
            );
        }
        // verify the required parameter 'launch_link_request' is set
        if ($launch_link_request === null || (is_array($launch_link_request) && count($launch_link_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $launch_link_request when calling buildCoursePreviewLaunchLinkWithVersion'
            );
        }

        $resourcePath = '/courses/{courseId}/versions/{versionId}/preview';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($course_id !== null) {
            $resourcePath = str_replace(
                '{' . 'courseId' . '}',
                ObjectSerializer::toPathValue($course_id),
                $resourcePath
            );
        }
        // path params
        if ($version_id !== null) {
            $resourcePath = str_replace(
                '{' . 'versionId' . '}',
                ObjectSerializer::toPathValue($version_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($launch_link_request)) {
            $_tempBody = $launch_link_request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createFetchAndImportCourseJob
     *
     * Fetch and import a course.
     *
     * @param  string $course_id A unique identifier your application will use to identify the course after import. Your application is responsible both for generating this unique ID and for keeping track of the ID for later use. (required)
     * @param  \RusticiSoftware\Cloud\V2\Model\ImportFetchRequestSchema $import_request import_request (required)
     * @param  bool $may_create_new_version Is it OK to create a new version of this course? If this is set to false and the course already exists, the upload will fail. If true and the course already exists then a new version will be created. No effect if the course doesn&#39;t already exist. (optional, default to false)
     * @param  string $postback_url An optional parameter that specifies a URL to send a postback to when the course has finished uploading. (optional)
     *
     * @throws \RusticiSoftware\Cloud\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \RusticiSoftware\Cloud\V2\Model\StringResultSchema
     */
    public function createFetchAndImportCourseJob($course_id, $import_request, $may_create_new_version = 'false', $postback_url = null)
    {
        list($response) = $this->createFetchAndImportCourseJobWithHttpInfo($course_id, $import_request, $may_create_new_version, $postback_url);
        return $response;
    }

    /**
     * Operation createFetchAndImportCourseJobWithHttpInfo
     *
     * Fetch and import a course.
     *
     * @param  string $course_id A unique identifier your application will use to identify the course after import. Your application is responsible both for generating this unique ID and for keeping track of the ID for later use. (required)
     * @param  \RusticiSoftware\Cloud\V2\Model\ImportFetchRequestSchema $import_request (required)
     * @param  bool $may_create_new_version Is it OK to create a new version of this course? If this is set to false and the course already exists, the upload will fail. If true and the course already exists then a new version will be created. No effect if the course doesn&#39;t already exist. (optional, default to false)
     * @param  string $postback_url An optional parameter that specifies a URL to send a postback to when the course has finished uploading. (optional)
     *
     * @throws \RusticiSoftware\Cloud\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \RusticiSoftware\Cloud\V2\Model\StringResultSchema, HTTP status code, HTTP response headers (array of strings)
     */
    public function createFetchAndImportCourseJobWithHttpInfo($course_id, $import_request, $may_create_new_version = 'false', $postback_url = null)
    {
        $returnType = '\RusticiSoftware\Cloud\V2\Model\StringResultSchema';
        $request = $this->createFetchAndImportCourseJobRequest($course_id, $import_request, $may_create_new_version, $postback_url);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Cloud\V2\Model\StringResultSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Cloud\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 409:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Cloud\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createFetchAndImportCourseJobAsync
     *
     * Fetch and import a course.
     *
     * @param  string $course_id A unique identifier your application will use to identify the course after import. Your application is responsible both for generating this unique ID and for keeping track of the ID for later use. (required)
     * @param  \RusticiSoftware\Cloud\V2\Model\ImportFetchRequestSchema $import_request (required)
     * @param  bool $may_create_new_version Is it OK to create a new version of this course? If this is set to false and the course already exists, the upload will fail. If true and the course already exists then a new version will be created. No effect if the course doesn&#39;t already exist. (optional, default to false)
     * @param  string $postback_url An optional parameter that specifies a URL to send a postback to when the course has finished uploading. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createFetchAndImportCourseJobAsync($course_id, $import_request, $may_create_new_version = 'false', $postback_url = null)
    {
        return $this->createFetchAndImportCourseJobAsyncWithHttpInfo($course_id, $import_request, $may_create_new_version, $postback_url)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createFetchAndImportCourseJobAsyncWithHttpInfo
     *
     * Fetch and import a course.
     *
     * @param  string $course_id A unique identifier your application will use to identify the course after import. Your application is responsible both for generating this unique ID and for keeping track of the ID for later use. (required)
     * @param  \RusticiSoftware\Cloud\V2\Model\ImportFetchRequestSchema $import_request (required)
     * @param  bool $may_create_new_version Is it OK to create a new version of this course? If this is set to false and the course already exists, the upload will fail. If true and the course already exists then a new version will be created. No effect if the course doesn&#39;t already exist. (optional, default to false)
     * @param  string $postback_url An optional parameter that specifies a URL to send a postback to when the course has finished uploading. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createFetchAndImportCourseJobAsyncWithHttpInfo($course_id, $import_request, $may_create_new_version = 'false', $postback_url = null)
    {
        $returnType = '\RusticiSoftware\Cloud\V2\Model\StringResultSchema';
        $request = $this->createFetchAndImportCourseJobRequest($course_id, $import_request, $may_create_new_version, $postback_url);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createFetchAndImportCourseJob'
     *
     * @param  string $course_id A unique identifier your application will use to identify the course after import. Your application is responsible both for generating this unique ID and for keeping track of the ID for later use. (required)
     * @param  \RusticiSoftware\Cloud\V2\Model\ImportFetchRequestSchema $import_request (required)
     * @param  bool $may_create_new_version Is it OK to create a new version of this course? If this is set to false and the course already exists, the upload will fail. If true and the course already exists then a new version will be created. No effect if the course doesn&#39;t already exist. (optional, default to false)
     * @param  string $postback_url An optional parameter that specifies a URL to send a postback to when the course has finished uploading. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createFetchAndImportCourseJobRequest($course_id, $import_request, $may_create_new_version = 'false', $postback_url = null)
    {
        // verify the required parameter 'course_id' is set
        if ($course_id === null || (is_array($course_id) && count($course_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $course_id when calling createFetchAndImportCourseJob'
            );
        }
        // verify the required parameter 'import_request' is set
        if ($import_request === null || (is_array($import_request) && count($import_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $import_request when calling createFetchAndImportCourseJob'
            );
        }

        $resourcePath = '/courses/importJobs';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($course_id !== null) {
            $queryParams['courseId'] = ObjectSerializer::toQueryValue($course_id);
        }
        // query params
        if ($may_create_new_version !== null) {
            $queryParams['mayCreateNewVersion'] = ObjectSerializer::toQueryValue($may_create_new_version);
        }
        // query params
        if ($postback_url !== null) {
            $queryParams['postbackUrl'] = ObjectSerializer::toQueryValue($postback_url);
        }


        // body params
        $_tempBody = null;
        if (isset($import_request)) {
            $_tempBody = $import_request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createNoUploadAndImportCourseJob
     *
     * Import a course that fetches or references an external media file
     *
     * @param  string $course_id A unique identifier your application will use to identify the course after import. Your application is responsible both for generating this unique ID and for keeping track of the ID for later use. (required)
     * @param  \RusticiSoftware\Cloud\V2\Model\ImportRequestSchema $import_request import_request (required)
     * @param  bool $may_create_new_version Is it OK to create a new version of this course? If this is set to false and the course already exists, the upload will fail. If true and the course already exists then a new version will be created. No effect if the course doesn&#39;t already exist. (optional, default to false)
     * @param  string $postback_url An optional parameter that specifies a URL to send a postback to when the course has finished uploading. (optional)
     *
     * @throws \RusticiSoftware\Cloud\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \RusticiSoftware\Cloud\V2\Model\StringResultSchema
     */
    public function createNoUploadAndImportCourseJob($course_id, $import_request, $may_create_new_version = 'false', $postback_url = null)
    {
        list($response) = $this->createNoUploadAndImportCourseJobWithHttpInfo($course_id, $import_request, $may_create_new_version, $postback_url);
        return $response;
    }

    /**
     * Operation createNoUploadAndImportCourseJobWithHttpInfo
     *
     * Import a course that fetches or references an external media file
     *
     * @param  string $course_id A unique identifier your application will use to identify the course after import. Your application is responsible both for generating this unique ID and for keeping track of the ID for later use. (required)
     * @param  \RusticiSoftware\Cloud\V2\Model\ImportRequestSchema $import_request (required)
     * @param  bool $may_create_new_version Is it OK to create a new version of this course? If this is set to false and the course already exists, the upload will fail. If true and the course already exists then a new version will be created. No effect if the course doesn&#39;t already exist. (optional, default to false)
     * @param  string $postback_url An optional parameter that specifies a URL to send a postback to when the course has finished uploading. (optional)
     *
     * @throws \RusticiSoftware\Cloud\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \RusticiSoftware\Cloud\V2\Model\StringResultSchema, HTTP status code, HTTP response headers (array of strings)
     */
    public function createNoUploadAndImportCourseJobWithHttpInfo($course_id, $import_request, $may_create_new_version = 'false', $postback_url = null)
    {
        $returnType = '\RusticiSoftware\Cloud\V2\Model\StringResultSchema';
        $request = $this->createNoUploadAndImportCourseJobRequest($course_id, $import_request, $may_create_new_version, $postback_url);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Cloud\V2\Model\StringResultSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Cloud\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 409:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Cloud\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createNoUploadAndImportCourseJobAsync
     *
     * Import a course that fetches or references an external media file
     *
     * @param  string $course_id A unique identifier your application will use to identify the course after import. Your application is responsible both for generating this unique ID and for keeping track of the ID for later use. (required)
     * @param  \RusticiSoftware\Cloud\V2\Model\ImportRequestSchema $import_request (required)
     * @param  bool $may_create_new_version Is it OK to create a new version of this course? If this is set to false and the course already exists, the upload will fail. If true and the course already exists then a new version will be created. No effect if the course doesn&#39;t already exist. (optional, default to false)
     * @param  string $postback_url An optional parameter that specifies a URL to send a postback to when the course has finished uploading. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createNoUploadAndImportCourseJobAsync($course_id, $import_request, $may_create_new_version = 'false', $postback_url = null)
    {
        return $this->createNoUploadAndImportCourseJobAsyncWithHttpInfo($course_id, $import_request, $may_create_new_version, $postback_url)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createNoUploadAndImportCourseJobAsyncWithHttpInfo
     *
     * Import a course that fetches or references an external media file
     *
     * @param  string $course_id A unique identifier your application will use to identify the course after import. Your application is responsible both for generating this unique ID and for keeping track of the ID for later use. (required)
     * @param  \RusticiSoftware\Cloud\V2\Model\ImportRequestSchema $import_request (required)
     * @param  bool $may_create_new_version Is it OK to create a new version of this course? If this is set to false and the course already exists, the upload will fail. If true and the course already exists then a new version will be created. No effect if the course doesn&#39;t already exist. (optional, default to false)
     * @param  string $postback_url An optional parameter that specifies a URL to send a postback to when the course has finished uploading. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createNoUploadAndImportCourseJobAsyncWithHttpInfo($course_id, $import_request, $may_create_new_version = 'false', $postback_url = null)
    {
        $returnType = '\RusticiSoftware\Cloud\V2\Model\StringResultSchema';
        $request = $this->createNoUploadAndImportCourseJobRequest($course_id, $import_request, $may_create_new_version, $postback_url);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createNoUploadAndImportCourseJob'
     *
     * @param  string $course_id A unique identifier your application will use to identify the course after import. Your application is responsible both for generating this unique ID and for keeping track of the ID for later use. (required)
     * @param  \RusticiSoftware\Cloud\V2\Model\ImportRequestSchema $import_request (required)
     * @param  bool $may_create_new_version Is it OK to create a new version of this course? If this is set to false and the course already exists, the upload will fail. If true and the course already exists then a new version will be created. No effect if the course doesn&#39;t already exist. (optional, default to false)
     * @param  string $postback_url An optional parameter that specifies a URL to send a postback to when the course has finished uploading. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createNoUploadAndImportCourseJobRequest($course_id, $import_request, $may_create_new_version = 'false', $postback_url = null)
    {
        // verify the required parameter 'course_id' is set
        if ($course_id === null || (is_array($course_id) && count($course_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $course_id when calling createNoUploadAndImportCourseJob'
            );
        }
        // verify the required parameter 'import_request' is set
        if ($import_request === null || (is_array($import_request) && count($import_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $import_request when calling createNoUploadAndImportCourseJob'
            );
        }

        $resourcePath = '/courses/importJobs/noUpload';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($course_id !== null) {
            $queryParams['courseId'] = ObjectSerializer::toQueryValue($course_id);
        }
        // query params
        if ($may_create_new_version !== null) {
            $queryParams['mayCreateNewVersion'] = ObjectSerializer::toQueryValue($may_create_new_version);
        }
        // query params
        if ($postback_url !== null) {
            $queryParams['postbackUrl'] = ObjectSerializer::toQueryValue($postback_url);
        }


        // body params
        $_tempBody = null;
        if (isset($import_request)) {
            $_tempBody = $import_request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createUploadAndImportCourseJob
     *
     * Upload and import a course.
     *
     * @param  string $course_id A unique identifier your application will use to identify the course after import. Your application is responsible both for generating this unique ID and for keeping track of the ID for later use. (required)
     * @param  bool $may_create_new_version Is it OK to create a new version of this course? If this is set to false and the course already exists, the upload will fail. If true and the course already exists then a new version will be created. No effect if the course doesn&#39;t already exist. (optional, default to false)
     * @param  string $postback_url An optional parameter that specifies a URL to send a postback to when the course has finished uploading. (optional)
     * @param  string $uploaded_content_type The MIME type identifier for the content to be uploaded. This is required if uploading a media file (.pdf, .mp3, or .mp4). (optional, default to application/zip)
     * @param  string $content_metadata Serialized &#39;mediaFileMetadata&#39; schema. (optional)
     * @param  \SplFileObject $file The zip file of the course contents to import. (optional)
     *
     * @throws \RusticiSoftware\Cloud\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \RusticiSoftware\Cloud\V2\Model\StringResultSchema
     */
    public function createUploadAndImportCourseJob($course_id, $may_create_new_version = 'false', $postback_url = null, $uploaded_content_type = 'application/zip', $content_metadata = null, $file = null)
    {
        list($response) = $this->createUploadAndImportCourseJobWithHttpInfo($course_id, $may_create_new_version, $postback_url, $uploaded_content_type, $content_metadata, $file);
        return $response;
    }

    /**
     * Operation createUploadAndImportCourseJobWithHttpInfo
     *
     * Upload and import a course.
     *
     * @param  string $course_id A unique identifier your application will use to identify the course after import. Your application is responsible both for generating this unique ID and for keeping track of the ID for later use. (required)
     * @param  bool $may_create_new_version Is it OK to create a new version of this course? If this is set to false and the course already exists, the upload will fail. If true and the course already exists then a new version will be created. No effect if the course doesn&#39;t already exist. (optional, default to false)
     * @param  string $postback_url An optional parameter that specifies a URL to send a postback to when the course has finished uploading. (optional)
     * @param  string $uploaded_content_type The MIME type identifier for the content to be uploaded. This is required if uploading a media file (.pdf, .mp3, or .mp4). (optional, default to application/zip)
     * @param  string $content_metadata Serialized &#39;mediaFileMetadata&#39; schema. (optional)
     * @param  \SplFileObject $file The zip file of the course contents to import. (optional)
     *
     * @throws \RusticiSoftware\Cloud\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \RusticiSoftware\Cloud\V2\Model\StringResultSchema, HTTP status code, HTTP response headers (array of strings)
     */
    public function createUploadAndImportCourseJobWithHttpInfo($course_id, $may_create_new_version = 'false', $postback_url = null, $uploaded_content_type = 'application/zip', $content_metadata = null, $file = null)
    {
        $returnType = '\RusticiSoftware\Cloud\V2\Model\StringResultSchema';
        $request = $this->createUploadAndImportCourseJobRequest($course_id, $may_create_new_version, $postback_url, $uploaded_content_type, $content_metadata, $file);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Cloud\V2\Model\StringResultSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Cloud\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 409:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Cloud\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createUploadAndImportCourseJobAsync
     *
     * Upload and import a course.
     *
     * @param  string $course_id A unique identifier your application will use to identify the course after import. Your application is responsible both for generating this unique ID and for keeping track of the ID for later use. (required)
     * @param  bool $may_create_new_version Is it OK to create a new version of this course? If this is set to false and the course already exists, the upload will fail. If true and the course already exists then a new version will be created. No effect if the course doesn&#39;t already exist. (optional, default to false)
     * @param  string $postback_url An optional parameter that specifies a URL to send a postback to when the course has finished uploading. (optional)
     * @param  string $uploaded_content_type The MIME type identifier for the content to be uploaded. This is required if uploading a media file (.pdf, .mp3, or .mp4). (optional, default to application/zip)
     * @param  string $content_metadata Serialized &#39;mediaFileMetadata&#39; schema. (optional)
     * @param  \SplFileObject $file The zip file of the course contents to import. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createUploadAndImportCourseJobAsync($course_id, $may_create_new_version = 'false', $postback_url = null, $uploaded_content_type = 'application/zip', $content_metadata = null, $file = null)
    {
        return $this->createUploadAndImportCourseJobAsyncWithHttpInfo($course_id, $may_create_new_version, $postback_url, $uploaded_content_type, $content_metadata, $file)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createUploadAndImportCourseJobAsyncWithHttpInfo
     *
     * Upload and import a course.
     *
     * @param  string $course_id A unique identifier your application will use to identify the course after import. Your application is responsible both for generating this unique ID and for keeping track of the ID for later use. (required)
     * @param  bool $may_create_new_version Is it OK to create a new version of this course? If this is set to false and the course already exists, the upload will fail. If true and the course already exists then a new version will be created. No effect if the course doesn&#39;t already exist. (optional, default to false)
     * @param  string $postback_url An optional parameter that specifies a URL to send a postback to when the course has finished uploading. (optional)
     * @param  string $uploaded_content_type The MIME type identifier for the content to be uploaded. This is required if uploading a media file (.pdf, .mp3, or .mp4). (optional, default to application/zip)
     * @param  string $content_metadata Serialized &#39;mediaFileMetadata&#39; schema. (optional)
     * @param  \SplFileObject $file The zip file of the course contents to import. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createUploadAndImportCourseJobAsyncWithHttpInfo($course_id, $may_create_new_version = 'false', $postback_url = null, $uploaded_content_type = 'application/zip', $content_metadata = null, $file = null)
    {
        $returnType = '\RusticiSoftware\Cloud\V2\Model\StringResultSchema';
        $request = $this->createUploadAndImportCourseJobRequest($course_id, $may_create_new_version, $postback_url, $uploaded_content_type, $content_metadata, $file);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createUploadAndImportCourseJob'
     *
     * @param  string $course_id A unique identifier your application will use to identify the course after import. Your application is responsible both for generating this unique ID and for keeping track of the ID for later use. (required)
     * @param  bool $may_create_new_version Is it OK to create a new version of this course? If this is set to false and the course already exists, the upload will fail. If true and the course already exists then a new version will be created. No effect if the course doesn&#39;t already exist. (optional, default to false)
     * @param  string $postback_url An optional parameter that specifies a URL to send a postback to when the course has finished uploading. (optional)
     * @param  string $uploaded_content_type The MIME type identifier for the content to be uploaded. This is required if uploading a media file (.pdf, .mp3, or .mp4). (optional, default to application/zip)
     * @param  string $content_metadata Serialized &#39;mediaFileMetadata&#39; schema. (optional)
     * @param  \SplFileObject $file The zip file of the course contents to import. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createUploadAndImportCourseJobRequest($course_id, $may_create_new_version = 'false', $postback_url = null, $uploaded_content_type = 'application/zip', $content_metadata = null, $file = null)
    {
        // verify the required parameter 'course_id' is set
        if ($course_id === null || (is_array($course_id) && count($course_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $course_id when calling createUploadAndImportCourseJob'
            );
        }

        $resourcePath = '/courses/importJobs/upload';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($course_id !== null) {
            $queryParams['courseId'] = ObjectSerializer::toQueryValue($course_id);
        }
        // query params
        if ($may_create_new_version !== null) {
            $queryParams['mayCreateNewVersion'] = ObjectSerializer::toQueryValue($may_create_new_version);
        }
        // query params
        if ($postback_url !== null) {
            $queryParams['postbackUrl'] = ObjectSerializer::toQueryValue($postback_url);
        }
        // header params
        if ($uploaded_content_type !== null) {
            $headerParams['uploadedContentType'] = ObjectSerializer::toHeaderValue($uploaded_content_type);
        }


        // form params
        if ($content_metadata !== null) {
            $formParams['contentMetadata'] = ObjectSerializer::toFormValue($content_metadata);
        }
        // form params
        if ($file !== null) {
            $multipart = true;
            $formParams['file'] = \GuzzleHttp\Psr7\try_fopen(ObjectSerializer::toFormValue($file), 'rb');
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['multipart/form-data']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteCourse
     *
     * Delete a course.
     *
     * @param  string $course_id course_id (required)
     *
     * @throws \RusticiSoftware\Cloud\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteCourse($course_id)
    {
        $this->deleteCourseWithHttpInfo($course_id);
    }

    /**
     * Operation deleteCourseWithHttpInfo
     *
     * Delete a course.
     *
     * @param  string $course_id (required)
     *
     * @throws \RusticiSoftware\Cloud\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteCourseWithHttpInfo($course_id)
    {
        $returnType = '';
        $request = $this->deleteCourseRequest($course_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Cloud\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Cloud\V2\Model\ResponseError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteCourseAsync
     *
     * Delete a course.
     *
     * @param  string $course_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteCourseAsync($course_id)
    {
        return $this->deleteCourseAsyncWithHttpInfo($course_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteCourseAsyncWithHttpInfo
     *
     * Delete a course.
     *
     * @param  string $course_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteCourseAsyncWithHttpInfo($course_id)
    {
        $returnType = '';
        $request = $this->deleteCourseRequest($course_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteCourse'
     *
     * @param  string $course_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteCourseRequest($course_id)
    {
        // verify the required parameter 'course_id' is set
        if ($course_id === null || (is_array($course_id) && count($course_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $course_id when calling deleteCourse'
            );
        }

        $resourcePath = '/courses/{courseId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($course_id !== null) {
            $resourcePath = str_replace(
                '{' . 'courseId' . '}',
                ObjectSerializer::toPathValue($course_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteCourseConfigurationSetting
     *
     * Clear a course configuration.
     *
     * @param  string $course_id course_id (required)
     * @param  string $setting_id setting_id (required)
     *
     * @throws \RusticiSoftware\Cloud\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteCourseConfigurationSetting($course_id, $setting_id)
    {
        $this->deleteCourseConfigurationSettingWithHttpInfo($course_id, $setting_id);
    }

    /**
     * Operation deleteCourseConfigurationSettingWithHttpInfo
     *
     * Clear a course configuration.
     *
     * @param  string $course_id (required)
     * @param  string $setting_id (required)
     *
     * @throws \RusticiSoftware\Cloud\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteCourseConfigurationSettingWithHttpInfo($course_id, $setting_id)
    {
        $returnType = '';
        $request = $this->deleteCourseConfigurationSettingRequest($course_id, $setting_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Cloud\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Cloud\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteCourseConfigurationSettingAsync
     *
     * Clear a course configuration.
     *
     * @param  string $course_id (required)
     * @param  string $setting_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteCourseConfigurationSettingAsync($course_id, $setting_id)
    {
        return $this->deleteCourseConfigurationSettingAsyncWithHttpInfo($course_id, $setting_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteCourseConfigurationSettingAsyncWithHttpInfo
     *
     * Clear a course configuration.
     *
     * @param  string $course_id (required)
     * @param  string $setting_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteCourseConfigurationSettingAsyncWithHttpInfo($course_id, $setting_id)
    {
        $returnType = '';
        $request = $this->deleteCourseConfigurationSettingRequest($course_id, $setting_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteCourseConfigurationSetting'
     *
     * @param  string $course_id (required)
     * @param  string $setting_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteCourseConfigurationSettingRequest($course_id, $setting_id)
    {
        // verify the required parameter 'course_id' is set
        if ($course_id === null || (is_array($course_id) && count($course_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $course_id when calling deleteCourseConfigurationSetting'
            );
        }
        // verify the required parameter 'setting_id' is set
        if ($setting_id === null || (is_array($setting_id) && count($setting_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $setting_id when calling deleteCourseConfigurationSetting'
            );
        }

        $resourcePath = '/courses/{courseId}/configuration/{settingId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($course_id !== null) {
            $resourcePath = str_replace(
                '{' . 'courseId' . '}',
                ObjectSerializer::toPathValue($course_id),
                $resourcePath
            );
        }
        // path params
        if ($setting_id !== null) {
            $resourcePath = str_replace(
                '{' . 'settingId' . '}',
                ObjectSerializer::toPathValue($setting_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteCourseTags
     *
     * Delete course tags.
     *
     * @param  string $course_id course_id (required)
     * @param  \RusticiSoftware\Cloud\V2\Model\TagListSchema $tags tags (required)
     *
     * @throws \RusticiSoftware\Cloud\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteCourseTags($course_id, $tags)
    {
        $this->deleteCourseTagsWithHttpInfo($course_id, $tags);
    }

    /**
     * Operation deleteCourseTagsWithHttpInfo
     *
     * Delete course tags.
     *
     * @param  string $course_id (required)
     * @param  \RusticiSoftware\Cloud\V2\Model\TagListSchema $tags (required)
     *
     * @throws \RusticiSoftware\Cloud\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteCourseTagsWithHttpInfo($course_id, $tags)
    {
        $returnType = '';
        $request = $this->deleteCourseTagsRequest($course_id, $tags);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Cloud\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Cloud\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteCourseTagsAsync
     *
     * Delete course tags.
     *
     * @param  string $course_id (required)
     * @param  \RusticiSoftware\Cloud\V2\Model\TagListSchema $tags (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteCourseTagsAsync($course_id, $tags)
    {
        return $this->deleteCourseTagsAsyncWithHttpInfo($course_id, $tags)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteCourseTagsAsyncWithHttpInfo
     *
     * Delete course tags.
     *
     * @param  string $course_id (required)
     * @param  \RusticiSoftware\Cloud\V2\Model\TagListSchema $tags (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteCourseTagsAsyncWithHttpInfo($course_id, $tags)
    {
        $returnType = '';
        $request = $this->deleteCourseTagsRequest($course_id, $tags);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteCourseTags'
     *
     * @param  string $course_id (required)
     * @param  \RusticiSoftware\Cloud\V2\Model\TagListSchema $tags (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteCourseTagsRequest($course_id, $tags)
    {
        // verify the required parameter 'course_id' is set
        if ($course_id === null || (is_array($course_id) && count($course_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $course_id when calling deleteCourseTags'
            );
        }
        // verify the required parameter 'tags' is set
        if ($tags === null || (is_array($tags) && count($tags) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $tags when calling deleteCourseTags'
            );
        }

        $resourcePath = '/courses/{courseId}/tags';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($course_id !== null) {
            $resourcePath = str_replace(
                '{' . 'courseId' . '}',
                ObjectSerializer::toPathValue($course_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($tags)) {
            $_tempBody = $tags;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteCourseVersion
     *
     * Delete a course version.
     *
     * @param  string $course_id course_id (required)
     * @param  int $version_id The course version (required)
     *
     * @throws \RusticiSoftware\Cloud\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteCourseVersion($course_id, $version_id)
    {
        $this->deleteCourseVersionWithHttpInfo($course_id, $version_id);
    }

    /**
     * Operation deleteCourseVersionWithHttpInfo
     *
     * Delete a course version.
     *
     * @param  string $course_id (required)
     * @param  int $version_id The course version (required)
     *
     * @throws \RusticiSoftware\Cloud\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteCourseVersionWithHttpInfo($course_id, $version_id)
    {
        $returnType = '';
        $request = $this->deleteCourseVersionRequest($course_id, $version_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Cloud\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Cloud\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteCourseVersionAsync
     *
     * Delete a course version.
     *
     * @param  string $course_id (required)
     * @param  int $version_id The course version (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteCourseVersionAsync($course_id, $version_id)
    {
        return $this->deleteCourseVersionAsyncWithHttpInfo($course_id, $version_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteCourseVersionAsyncWithHttpInfo
     *
     * Delete a course version.
     *
     * @param  string $course_id (required)
     * @param  int $version_id The course version (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteCourseVersionAsyncWithHttpInfo($course_id, $version_id)
    {
        $returnType = '';
        $request = $this->deleteCourseVersionRequest($course_id, $version_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteCourseVersion'
     *
     * @param  string $course_id (required)
     * @param  int $version_id The course version (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteCourseVersionRequest($course_id, $version_id)
    {
        // verify the required parameter 'course_id' is set
        if ($course_id === null || (is_array($course_id) && count($course_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $course_id when calling deleteCourseVersion'
            );
        }
        // verify the required parameter 'version_id' is set
        if ($version_id === null || (is_array($version_id) && count($version_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version_id when calling deleteCourseVersion'
            );
        }

        $resourcePath = '/courses/{courseId}/versions/{versionId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($course_id !== null) {
            $resourcePath = str_replace(
                '{' . 'courseId' . '}',
                ObjectSerializer::toPathValue($course_id),
                $resourcePath
            );
        }
        // path params
        if ($version_id !== null) {
            $resourcePath = str_replace(
                '{' . 'versionId' . '}',
                ObjectSerializer::toPathValue($version_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteCourseVersionConfigurationSetting
     *
     * Clear a configuration setting for a version of a course.
     *
     * @param  string $course_id course_id (required)
     * @param  int $version_id The course version (required)
     * @param  string $setting_id setting_id (required)
     *
     * @throws \RusticiSoftware\Cloud\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteCourseVersionConfigurationSetting($course_id, $version_id, $setting_id)
    {
        $this->deleteCourseVersionConfigurationSettingWithHttpInfo($course_id, $version_id, $setting_id);
    }

    /**
     * Operation deleteCourseVersionConfigurationSettingWithHttpInfo
     *
     * Clear a configuration setting for a version of a course.
     *
     * @param  string $course_id (required)
     * @param  int $version_id The course version (required)
     * @param  string $setting_id (required)
     *
     * @throws \RusticiSoftware\Cloud\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteCourseVersionConfigurationSettingWithHttpInfo($course_id, $version_id, $setting_id)
    {
        $returnType = '';
        $request = $this->deleteCourseVersionConfigurationSettingRequest($course_id, $version_id, $setting_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Cloud\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Cloud\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteCourseVersionConfigurationSettingAsync
     *
     * Clear a configuration setting for a version of a course.
     *
     * @param  string $course_id (required)
     * @param  int $version_id The course version (required)
     * @param  string $setting_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteCourseVersionConfigurationSettingAsync($course_id, $version_id, $setting_id)
    {
        return $this->deleteCourseVersionConfigurationSettingAsyncWithHttpInfo($course_id, $version_id, $setting_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteCourseVersionConfigurationSettingAsyncWithHttpInfo
     *
     * Clear a configuration setting for a version of a course.
     *
     * @param  string $course_id (required)
     * @param  int $version_id The course version (required)
     * @param  string $setting_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteCourseVersionConfigurationSettingAsyncWithHttpInfo($course_id, $version_id, $setting_id)
    {
        $returnType = '';
        $request = $this->deleteCourseVersionConfigurationSettingRequest($course_id, $version_id, $setting_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteCourseVersionConfigurationSetting'
     *
     * @param  string $course_id (required)
     * @param  int $version_id The course version (required)
     * @param  string $setting_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteCourseVersionConfigurationSettingRequest($course_id, $version_id, $setting_id)
    {
        // verify the required parameter 'course_id' is set
        if ($course_id === null || (is_array($course_id) && count($course_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $course_id when calling deleteCourseVersionConfigurationSetting'
            );
        }
        // verify the required parameter 'version_id' is set
        if ($version_id === null || (is_array($version_id) && count($version_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version_id when calling deleteCourseVersionConfigurationSetting'
            );
        }
        // verify the required parameter 'setting_id' is set
        if ($setting_id === null || (is_array($setting_id) && count($setting_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $setting_id when calling deleteCourseVersionConfigurationSetting'
            );
        }

        $resourcePath = '/courses/{courseId}/versions/{versionId}/configuration/{settingId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($course_id !== null) {
            $resourcePath = str_replace(
                '{' . 'courseId' . '}',
                ObjectSerializer::toPathValue($course_id),
                $resourcePath
            );
        }
        // path params
        if ($version_id !== null) {
            $resourcePath = str_replace(
                '{' . 'versionId' . '}',
                ObjectSerializer::toPathValue($version_id),
                $resourcePath
            );
        }
        // path params
        if ($setting_id !== null) {
            $resourcePath = str_replace(
                '{' . 'settingId' . '}',
                ObjectSerializer::toPathValue($setting_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCourse
     *
     * Get course details.
     *
     * @param  string $course_id course_id (required)
     * @param  bool $include_registration_count Include the registration count in the results (optional, default to false)
     * @param  bool $include_course_metadata Include course metadata in the results. If the course has no metadata, adding this parameter has no effect. (optional, default to false)
     *
     * @throws \RusticiSoftware\Cloud\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \RusticiSoftware\Cloud\V2\Model\CourseSchema
     */
    public function getCourse($course_id, $include_registration_count = 'false', $include_course_metadata = 'false')
    {
        list($response) = $this->getCourseWithHttpInfo($course_id, $include_registration_count, $include_course_metadata);
        return $response;
    }

    /**
     * Operation getCourseWithHttpInfo
     *
     * Get course details.
     *
     * @param  string $course_id (required)
     * @param  bool $include_registration_count Include the registration count in the results (optional, default to false)
     * @param  bool $include_course_metadata Include course metadata in the results. If the course has no metadata, adding this parameter has no effect. (optional, default to false)
     *
     * @throws \RusticiSoftware\Cloud\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \RusticiSoftware\Cloud\V2\Model\CourseSchema, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCourseWithHttpInfo($course_id, $include_registration_count = 'false', $include_course_metadata = 'false')
    {
        $returnType = '\RusticiSoftware\Cloud\V2\Model\CourseSchema';
        $request = $this->getCourseRequest($course_id, $include_registration_count, $include_course_metadata);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Cloud\V2\Model\CourseSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Cloud\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Cloud\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getCourseAsync
     *
     * Get course details.
     *
     * @param  string $course_id (required)
     * @param  bool $include_registration_count Include the registration count in the results (optional, default to false)
     * @param  bool $include_course_metadata Include course metadata in the results. If the course has no metadata, adding this parameter has no effect. (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCourseAsync($course_id, $include_registration_count = 'false', $include_course_metadata = 'false')
    {
        return $this->getCourseAsyncWithHttpInfo($course_id, $include_registration_count, $include_course_metadata)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCourseAsyncWithHttpInfo
     *
     * Get course details.
     *
     * @param  string $course_id (required)
     * @param  bool $include_registration_count Include the registration count in the results (optional, default to false)
     * @param  bool $include_course_metadata Include course metadata in the results. If the course has no metadata, adding this parameter has no effect. (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCourseAsyncWithHttpInfo($course_id, $include_registration_count = 'false', $include_course_metadata = 'false')
    {
        $returnType = '\RusticiSoftware\Cloud\V2\Model\CourseSchema';
        $request = $this->getCourseRequest($course_id, $include_registration_count, $include_course_metadata);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCourse'
     *
     * @param  string $course_id (required)
     * @param  bool $include_registration_count Include the registration count in the results (optional, default to false)
     * @param  bool $include_course_metadata Include course metadata in the results. If the course has no metadata, adding this parameter has no effect. (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getCourseRequest($course_id, $include_registration_count = 'false', $include_course_metadata = 'false')
    {
        // verify the required parameter 'course_id' is set
        if ($course_id === null || (is_array($course_id) && count($course_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $course_id when calling getCourse'
            );
        }

        $resourcePath = '/courses/{courseId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($include_registration_count !== null) {
            $queryParams['includeRegistrationCount'] = ObjectSerializer::toQueryValue($include_registration_count);
        }
        // query params
        if ($include_course_metadata !== null) {
            $queryParams['includeCourseMetadata'] = ObjectSerializer::toQueryValue($include_course_metadata);
        }

        // path params
        if ($course_id !== null) {
            $resourcePath = str_replace(
                '{' . 'courseId' . '}',
                ObjectSerializer::toPathValue($course_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCourseConfiguration
     *
     * Get course configuration.
     *
     * @param  string $course_id course_id (required)
     * @param  bool $include_metadata include_metadata (optional, default to false)
     *
     * @throws \RusticiSoftware\Cloud\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \RusticiSoftware\Cloud\V2\Model\SettingListSchema
     */
    public function getCourseConfiguration($course_id, $include_metadata = 'false')
    {
        list($response) = $this->getCourseConfigurationWithHttpInfo($course_id, $include_metadata);
        return $response;
    }

    /**
     * Operation getCourseConfigurationWithHttpInfo
     *
     * Get course configuration.
     *
     * @param  string $course_id (required)
     * @param  bool $include_metadata (optional, default to false)
     *
     * @throws \RusticiSoftware\Cloud\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \RusticiSoftware\Cloud\V2\Model\SettingListSchema, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCourseConfigurationWithHttpInfo($course_id, $include_metadata = 'false')
    {
        $returnType = '\RusticiSoftware\Cloud\V2\Model\SettingListSchema';
        $request = $this->getCourseConfigurationRequest($course_id, $include_metadata);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Cloud\V2\Model\SettingListSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Cloud\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Cloud\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getCourseConfigurationAsync
     *
     * Get course configuration.
     *
     * @param  string $course_id (required)
     * @param  bool $include_metadata (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCourseConfigurationAsync($course_id, $include_metadata = 'false')
    {
        return $this->getCourseConfigurationAsyncWithHttpInfo($course_id, $include_metadata)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCourseConfigurationAsyncWithHttpInfo
     *
     * Get course configuration.
     *
     * @param  string $course_id (required)
     * @param  bool $include_metadata (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCourseConfigurationAsyncWithHttpInfo($course_id, $include_metadata = 'false')
    {
        $returnType = '\RusticiSoftware\Cloud\V2\Model\SettingListSchema';
        $request = $this->getCourseConfigurationRequest($course_id, $include_metadata);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCourseConfiguration'
     *
     * @param  string $course_id (required)
     * @param  bool $include_metadata (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getCourseConfigurationRequest($course_id, $include_metadata = 'false')
    {
        // verify the required parameter 'course_id' is set
        if ($course_id === null || (is_array($course_id) && count($course_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $course_id when calling getCourseConfiguration'
            );
        }

        $resourcePath = '/courses/{courseId}/configuration';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($include_metadata !== null) {
            $queryParams['includeMetadata'] = ObjectSerializer::toQueryValue($include_metadata);
        }

        // path params
        if ($course_id !== null) {
            $resourcePath = str_replace(
                '{' . 'courseId' . '}',
                ObjectSerializer::toPathValue($course_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCourseStatements
     *
     * Get course xAPI statements.
     *
     * @param  string $course_id course_id (required)
     * @param  string $learner_id Only entries for the specified learner id will be included. (optional)
     * @param  \DateTime $since Only items updated since the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used. (optional)
     * @param  \DateTime $until Only items updated before the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used. (optional)
     * @param  string $more Value for this parameter will be provided in the &#39;more&#39; property of registration lists, where needed. An opaque value, construction and parsing may change without notice. (optional)
     *
     * @throws \RusticiSoftware\Cloud\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \RusticiSoftware\Cloud\V2\Model\XapiStatementResult
     */
    public function getCourseStatements($course_id, $learner_id = null, $since = null, $until = null, $more = null)
    {
        list($response) = $this->getCourseStatementsWithHttpInfo($course_id, $learner_id, $since, $until, $more);
        return $response;
    }

    /**
     * Operation getCourseStatementsWithHttpInfo
     *
     * Get course xAPI statements.
     *
     * @param  string $course_id (required)
     * @param  string $learner_id Only entries for the specified learner id will be included. (optional)
     * @param  \DateTime $since Only items updated since the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used. (optional)
     * @param  \DateTime $until Only items updated before the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used. (optional)
     * @param  string $more Value for this parameter will be provided in the &#39;more&#39; property of registration lists, where needed. An opaque value, construction and parsing may change without notice. (optional)
     *
     * @throws \RusticiSoftware\Cloud\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \RusticiSoftware\Cloud\V2\Model\XapiStatementResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCourseStatementsWithHttpInfo($course_id, $learner_id = null, $since = null, $until = null, $more = null)
    {
        $returnType = '\RusticiSoftware\Cloud\V2\Model\XapiStatementResult';
        $request = $this->getCourseStatementsRequest($course_id, $learner_id, $since, $until, $more);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Cloud\V2\Model\XapiStatementResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Cloud\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Cloud\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getCourseStatementsAsync
     *
     * Get course xAPI statements.
     *
     * @param  string $course_id (required)
     * @param  string $learner_id Only entries for the specified learner id will be included. (optional)
     * @param  \DateTime $since Only items updated since the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used. (optional)
     * @param  \DateTime $until Only items updated before the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used. (optional)
     * @param  string $more Value for this parameter will be provided in the &#39;more&#39; property of registration lists, where needed. An opaque value, construction and parsing may change without notice. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCourseStatementsAsync($course_id, $learner_id = null, $since = null, $until = null, $more = null)
    {
        return $this->getCourseStatementsAsyncWithHttpInfo($course_id, $learner_id, $since, $until, $more)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCourseStatementsAsyncWithHttpInfo
     *
     * Get course xAPI statements.
     *
     * @param  string $course_id (required)
     * @param  string $learner_id Only entries for the specified learner id will be included. (optional)
     * @param  \DateTime $since Only items updated since the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used. (optional)
     * @param  \DateTime $until Only items updated before the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used. (optional)
     * @param  string $more Value for this parameter will be provided in the &#39;more&#39; property of registration lists, where needed. An opaque value, construction and parsing may change without notice. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCourseStatementsAsyncWithHttpInfo($course_id, $learner_id = null, $since = null, $until = null, $more = null)
    {
        $returnType = '\RusticiSoftware\Cloud\V2\Model\XapiStatementResult';
        $request = $this->getCourseStatementsRequest($course_id, $learner_id, $since, $until, $more);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCourseStatements'
     *
     * @param  string $course_id (required)
     * @param  string $learner_id Only entries for the specified learner id will be included. (optional)
     * @param  \DateTime $since Only items updated since the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used. (optional)
     * @param  \DateTime $until Only items updated before the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used. (optional)
     * @param  string $more Value for this parameter will be provided in the &#39;more&#39; property of registration lists, where needed. An opaque value, construction and parsing may change without notice. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getCourseStatementsRequest($course_id, $learner_id = null, $since = null, $until = null, $more = null)
    {
        // verify the required parameter 'course_id' is set
        if ($course_id === null || (is_array($course_id) && count($course_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $course_id when calling getCourseStatements'
            );
        }

        $resourcePath = '/courses/{courseId}/xAPIStatements';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($learner_id !== null) {
            $queryParams['learnerId'] = ObjectSerializer::toQueryValue($learner_id);
        }
        // query params
        if ($since !== null) {
            $queryParams['since'] = ObjectSerializer::toQueryValue($since);
        }
        // query params
        if ($until !== null) {
            $queryParams['until'] = ObjectSerializer::toQueryValue($until);
        }
        // query params
        if ($more !== null) {
            $queryParams['more'] = ObjectSerializer::toQueryValue($more);
        }

        // path params
        if ($course_id !== null) {
            $resourcePath = str_replace(
                '{' . 'courseId' . '}',
                ObjectSerializer::toPathValue($course_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCourseTags
     *
     * Get course tags.
     *
     * @param  string $course_id course_id (required)
     *
     * @throws \RusticiSoftware\Cloud\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \RusticiSoftware\Cloud\V2\Model\TagListSchema
     */
    public function getCourseTags($course_id)
    {
        list($response) = $this->getCourseTagsWithHttpInfo($course_id);
        return $response;
    }

    /**
     * Operation getCourseTagsWithHttpInfo
     *
     * Get course tags.
     *
     * @param  string $course_id (required)
     *
     * @throws \RusticiSoftware\Cloud\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \RusticiSoftware\Cloud\V2\Model\TagListSchema, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCourseTagsWithHttpInfo($course_id)
    {
        $returnType = '\RusticiSoftware\Cloud\V2\Model\TagListSchema';
        $request = $this->getCourseTagsRequest($course_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Cloud\V2\Model\TagListSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Cloud\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Cloud\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getCourseTagsAsync
     *
     * Get course tags.
     *
     * @param  string $course_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCourseTagsAsync($course_id)
    {
        return $this->getCourseTagsAsyncWithHttpInfo($course_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCourseTagsAsyncWithHttpInfo
     *
     * Get course tags.
     *
     * @param  string $course_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCourseTagsAsyncWithHttpInfo($course_id)
    {
        $returnType = '\RusticiSoftware\Cloud\V2\Model\TagListSchema';
        $request = $this->getCourseTagsRequest($course_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCourseTags'
     *
     * @param  string $course_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getCourseTagsRequest($course_id)
    {
        // verify the required parameter 'course_id' is set
        if ($course_id === null || (is_array($course_id) && count($course_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $course_id when calling getCourseTags'
            );
        }

        $resourcePath = '/courses/{courseId}/tags';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($course_id !== null) {
            $resourcePath = str_replace(
                '{' . 'courseId' . '}',
                ObjectSerializer::toPathValue($course_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCourseVersionConfiguration
     *
     * Get configuration for a version of a course.
     *
     * @param  string $course_id course_id (required)
     * @param  int $version_id The course version (required)
     * @param  bool $include_metadata include_metadata (optional, default to false)
     *
     * @throws \RusticiSoftware\Cloud\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \RusticiSoftware\Cloud\V2\Model\SettingListSchema
     */
    public function getCourseVersionConfiguration($course_id, $version_id, $include_metadata = 'false')
    {
        list($response) = $this->getCourseVersionConfigurationWithHttpInfo($course_id, $version_id, $include_metadata);
        return $response;
    }

    /**
     * Operation getCourseVersionConfigurationWithHttpInfo
     *
     * Get configuration for a version of a course.
     *
     * @param  string $course_id (required)
     * @param  int $version_id The course version (required)
     * @param  bool $include_metadata (optional, default to false)
     *
     * @throws \RusticiSoftware\Cloud\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \RusticiSoftware\Cloud\V2\Model\SettingListSchema, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCourseVersionConfigurationWithHttpInfo($course_id, $version_id, $include_metadata = 'false')
    {
        $returnType = '\RusticiSoftware\Cloud\V2\Model\SettingListSchema';
        $request = $this->getCourseVersionConfigurationRequest($course_id, $version_id, $include_metadata);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Cloud\V2\Model\SettingListSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Cloud\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Cloud\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getCourseVersionConfigurationAsync
     *
     * Get configuration for a version of a course.
     *
     * @param  string $course_id (required)
     * @param  int $version_id The course version (required)
     * @param  bool $include_metadata (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCourseVersionConfigurationAsync($course_id, $version_id, $include_metadata = 'false')
    {
        return $this->getCourseVersionConfigurationAsyncWithHttpInfo($course_id, $version_id, $include_metadata)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCourseVersionConfigurationAsyncWithHttpInfo
     *
     * Get configuration for a version of a course.
     *
     * @param  string $course_id (required)
     * @param  int $version_id The course version (required)
     * @param  bool $include_metadata (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCourseVersionConfigurationAsyncWithHttpInfo($course_id, $version_id, $include_metadata = 'false')
    {
        $returnType = '\RusticiSoftware\Cloud\V2\Model\SettingListSchema';
        $request = $this->getCourseVersionConfigurationRequest($course_id, $version_id, $include_metadata);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCourseVersionConfiguration'
     *
     * @param  string $course_id (required)
     * @param  int $version_id The course version (required)
     * @param  bool $include_metadata (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getCourseVersionConfigurationRequest($course_id, $version_id, $include_metadata = 'false')
    {
        // verify the required parameter 'course_id' is set
        if ($course_id === null || (is_array($course_id) && count($course_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $course_id when calling getCourseVersionConfiguration'
            );
        }
        // verify the required parameter 'version_id' is set
        if ($version_id === null || (is_array($version_id) && count($version_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version_id when calling getCourseVersionConfiguration'
            );
        }

        $resourcePath = '/courses/{courseId}/versions/{versionId}/configuration';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($include_metadata !== null) {
            $queryParams['includeMetadata'] = ObjectSerializer::toQueryValue($include_metadata);
        }

        // path params
        if ($course_id !== null) {
            $resourcePath = str_replace(
                '{' . 'courseId' . '}',
                ObjectSerializer::toPathValue($course_id),
                $resourcePath
            );
        }
        // path params
        if ($version_id !== null) {
            $resourcePath = str_replace(
                '{' . 'versionId' . '}',
                ObjectSerializer::toPathValue($version_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCourseVersionInfo
     *
     * Get details on a course version.
     *
     * @param  string $course_id course_id (required)
     * @param  int $version_id The course version (required)
     * @param  bool $include_registration_count Include the registration count in the results (optional, default to false)
     * @param  bool $include_course_metadata Include course metadata in the results. If the course has no metadata, adding this parameter has no effect. (optional, default to false)
     *
     * @throws \RusticiSoftware\Cloud\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \RusticiSoftware\Cloud\V2\Model\CourseSchema
     */
    public function getCourseVersionInfo($course_id, $version_id, $include_registration_count = 'false', $include_course_metadata = 'false')
    {
        list($response) = $this->getCourseVersionInfoWithHttpInfo($course_id, $version_id, $include_registration_count, $include_course_metadata);
        return $response;
    }

    /**
     * Operation getCourseVersionInfoWithHttpInfo
     *
     * Get details on a course version.
     *
     * @param  string $course_id (required)
     * @param  int $version_id The course version (required)
     * @param  bool $include_registration_count Include the registration count in the results (optional, default to false)
     * @param  bool $include_course_metadata Include course metadata in the results. If the course has no metadata, adding this parameter has no effect. (optional, default to false)
     *
     * @throws \RusticiSoftware\Cloud\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \RusticiSoftware\Cloud\V2\Model\CourseSchema, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCourseVersionInfoWithHttpInfo($course_id, $version_id, $include_registration_count = 'false', $include_course_metadata = 'false')
    {
        $returnType = '\RusticiSoftware\Cloud\V2\Model\CourseSchema';
        $request = $this->getCourseVersionInfoRequest($course_id, $version_id, $include_registration_count, $include_course_metadata);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Cloud\V2\Model\CourseSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Cloud\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Cloud\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getCourseVersionInfoAsync
     *
     * Get details on a course version.
     *
     * @param  string $course_id (required)
     * @param  int $version_id The course version (required)
     * @param  bool $include_registration_count Include the registration count in the results (optional, default to false)
     * @param  bool $include_course_metadata Include course metadata in the results. If the course has no metadata, adding this parameter has no effect. (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCourseVersionInfoAsync($course_id, $version_id, $include_registration_count = 'false', $include_course_metadata = 'false')
    {
        return $this->getCourseVersionInfoAsyncWithHttpInfo($course_id, $version_id, $include_registration_count, $include_course_metadata)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCourseVersionInfoAsyncWithHttpInfo
     *
     * Get details on a course version.
     *
     * @param  string $course_id (required)
     * @param  int $version_id The course version (required)
     * @param  bool $include_registration_count Include the registration count in the results (optional, default to false)
     * @param  bool $include_course_metadata Include course metadata in the results. If the course has no metadata, adding this parameter has no effect. (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCourseVersionInfoAsyncWithHttpInfo($course_id, $version_id, $include_registration_count = 'false', $include_course_metadata = 'false')
    {
        $returnType = '\RusticiSoftware\Cloud\V2\Model\CourseSchema';
        $request = $this->getCourseVersionInfoRequest($course_id, $version_id, $include_registration_count, $include_course_metadata);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCourseVersionInfo'
     *
     * @param  string $course_id (required)
     * @param  int $version_id The course version (required)
     * @param  bool $include_registration_count Include the registration count in the results (optional, default to false)
     * @param  bool $include_course_metadata Include course metadata in the results. If the course has no metadata, adding this parameter has no effect. (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getCourseVersionInfoRequest($course_id, $version_id, $include_registration_count = 'false', $include_course_metadata = 'false')
    {
        // verify the required parameter 'course_id' is set
        if ($course_id === null || (is_array($course_id) && count($course_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $course_id when calling getCourseVersionInfo'
            );
        }
        // verify the required parameter 'version_id' is set
        if ($version_id === null || (is_array($version_id) && count($version_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version_id when calling getCourseVersionInfo'
            );
        }

        $resourcePath = '/courses/{courseId}/versions/{versionId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($include_registration_count !== null) {
            $queryParams['includeRegistrationCount'] = ObjectSerializer::toQueryValue($include_registration_count);
        }
        // query params
        if ($include_course_metadata !== null) {
            $queryParams['includeCourseMetadata'] = ObjectSerializer::toQueryValue($include_course_metadata);
        }

        // path params
        if ($course_id !== null) {
            $resourcePath = str_replace(
                '{' . 'courseId' . '}',
                ObjectSerializer::toPathValue($course_id),
                $resourcePath
            );
        }
        // path params
        if ($version_id !== null) {
            $resourcePath = str_replace(
                '{' . 'versionId' . '}',
                ObjectSerializer::toPathValue($version_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCourseVersionStatements
     *
     * Get xAPI statements for a course version.
     *
     * @param  string $course_id course_id (required)
     * @param  int $version_id The course version (required)
     * @param  string $learner_id Only entries for the specified learner id will be included. (optional)
     * @param  \DateTime $since Only items updated since the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used. (optional)
     * @param  \DateTime $until Only items updated before the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used. (optional)
     * @param  string $more Value for this parameter will be provided in the &#39;more&#39; property of registration lists, where needed. An opaque value, construction and parsing may change without notice. (optional)
     *
     * @throws \RusticiSoftware\Cloud\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \RusticiSoftware\Cloud\V2\Model\XapiStatementResult
     */
    public function getCourseVersionStatements($course_id, $version_id, $learner_id = null, $since = null, $until = null, $more = null)
    {
        list($response) = $this->getCourseVersionStatementsWithHttpInfo($course_id, $version_id, $learner_id, $since, $until, $more);
        return $response;
    }

    /**
     * Operation getCourseVersionStatementsWithHttpInfo
     *
     * Get xAPI statements for a course version.
     *
     * @param  string $course_id (required)
     * @param  int $version_id The course version (required)
     * @param  string $learner_id Only entries for the specified learner id will be included. (optional)
     * @param  \DateTime $since Only items updated since the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used. (optional)
     * @param  \DateTime $until Only items updated before the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used. (optional)
     * @param  string $more Value for this parameter will be provided in the &#39;more&#39; property of registration lists, where needed. An opaque value, construction and parsing may change without notice. (optional)
     *
     * @throws \RusticiSoftware\Cloud\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \RusticiSoftware\Cloud\V2\Model\XapiStatementResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCourseVersionStatementsWithHttpInfo($course_id, $version_id, $learner_id = null, $since = null, $until = null, $more = null)
    {
        $returnType = '\RusticiSoftware\Cloud\V2\Model\XapiStatementResult';
        $request = $this->getCourseVersionStatementsRequest($course_id, $version_id, $learner_id, $since, $until, $more);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Cloud\V2\Model\XapiStatementResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Cloud\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Cloud\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getCourseVersionStatementsAsync
     *
     * Get xAPI statements for a course version.
     *
     * @param  string $course_id (required)
     * @param  int $version_id The course version (required)
     * @param  string $learner_id Only entries for the specified learner id will be included. (optional)
     * @param  \DateTime $since Only items updated since the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used. (optional)
     * @param  \DateTime $until Only items updated before the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used. (optional)
     * @param  string $more Value for this parameter will be provided in the &#39;more&#39; property of registration lists, where needed. An opaque value, construction and parsing may change without notice. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCourseVersionStatementsAsync($course_id, $version_id, $learner_id = null, $since = null, $until = null, $more = null)
    {
        return $this->getCourseVersionStatementsAsyncWithHttpInfo($course_id, $version_id, $learner_id, $since, $until, $more)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCourseVersionStatementsAsyncWithHttpInfo
     *
     * Get xAPI statements for a course version.
     *
     * @param  string $course_id (required)
     * @param  int $version_id The course version (required)
     * @param  string $learner_id Only entries for the specified learner id will be included. (optional)
     * @param  \DateTime $since Only items updated since the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used. (optional)
     * @param  \DateTime $until Only items updated before the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used. (optional)
     * @param  string $more Value for this parameter will be provided in the &#39;more&#39; property of registration lists, where needed. An opaque value, construction and parsing may change without notice. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCourseVersionStatementsAsyncWithHttpInfo($course_id, $version_id, $learner_id = null, $since = null, $until = null, $more = null)
    {
        $returnType = '\RusticiSoftware\Cloud\V2\Model\XapiStatementResult';
        $request = $this->getCourseVersionStatementsRequest($course_id, $version_id, $learner_id, $since, $until, $more);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCourseVersionStatements'
     *
     * @param  string $course_id (required)
     * @param  int $version_id The course version (required)
     * @param  string $learner_id Only entries for the specified learner id will be included. (optional)
     * @param  \DateTime $since Only items updated since the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used. (optional)
     * @param  \DateTime $until Only items updated before the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used. (optional)
     * @param  string $more Value for this parameter will be provided in the &#39;more&#39; property of registration lists, where needed. An opaque value, construction and parsing may change without notice. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getCourseVersionStatementsRequest($course_id, $version_id, $learner_id = null, $since = null, $until = null, $more = null)
    {
        // verify the required parameter 'course_id' is set
        if ($course_id === null || (is_array($course_id) && count($course_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $course_id when calling getCourseVersionStatements'
            );
        }
        // verify the required parameter 'version_id' is set
        if ($version_id === null || (is_array($version_id) && count($version_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version_id when calling getCourseVersionStatements'
            );
        }

        $resourcePath = '/courses/{courseId}/versions/{versionId}/xAPIStatements';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($learner_id !== null) {
            $queryParams['learnerId'] = ObjectSerializer::toQueryValue($learner_id);
        }
        // query params
        if ($since !== null) {
            $queryParams['since'] = ObjectSerializer::toQueryValue($since);
        }
        // query params
        if ($until !== null) {
            $queryParams['until'] = ObjectSerializer::toQueryValue($until);
        }
        // query params
        if ($more !== null) {
            $queryParams['more'] = ObjectSerializer::toQueryValue($more);
        }

        // path params
        if ($course_id !== null) {
            $resourcePath = str_replace(
                '{' . 'courseId' . '}',
                ObjectSerializer::toPathValue($course_id),
                $resourcePath
            );
        }
        // path params
        if ($version_id !== null) {
            $resourcePath = str_replace(
                '{' . 'versionId' . '}',
                ObjectSerializer::toPathValue($version_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCourseVersions
     *
     * Get details on a course's versions.
     *
     * @param  string $course_id course_id (required)
     * @param  \DateTime $since Only items updated since the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used. (optional)
     * @param  \DateTime $until Only items updated before the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used. (optional)
     * @param  bool $include_registration_count Include the registration count in the results (optional, default to false)
     * @param  bool $include_course_metadata Include course metadata in the results. If the course has no metadata, adding this parameter has no effect. (optional, default to false)
     *
     * @throws \RusticiSoftware\Cloud\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \RusticiSoftware\Cloud\V2\Model\CourseListNonPagedSchema
     */
    public function getCourseVersions($course_id, $since = null, $until = null, $include_registration_count = 'false', $include_course_metadata = 'false')
    {
        list($response) = $this->getCourseVersionsWithHttpInfo($course_id, $since, $until, $include_registration_count, $include_course_metadata);
        return $response;
    }

    /**
     * Operation getCourseVersionsWithHttpInfo
     *
     * Get details on a course's versions.
     *
     * @param  string $course_id (required)
     * @param  \DateTime $since Only items updated since the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used. (optional)
     * @param  \DateTime $until Only items updated before the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used. (optional)
     * @param  bool $include_registration_count Include the registration count in the results (optional, default to false)
     * @param  bool $include_course_metadata Include course metadata in the results. If the course has no metadata, adding this parameter has no effect. (optional, default to false)
     *
     * @throws \RusticiSoftware\Cloud\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \RusticiSoftware\Cloud\V2\Model\CourseListNonPagedSchema, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCourseVersionsWithHttpInfo($course_id, $since = null, $until = null, $include_registration_count = 'false', $include_course_metadata = 'false')
    {
        $returnType = '\RusticiSoftware\Cloud\V2\Model\CourseListNonPagedSchema';
        $request = $this->getCourseVersionsRequest($course_id, $since, $until, $include_registration_count, $include_course_metadata);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Cloud\V2\Model\CourseListNonPagedSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Cloud\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Cloud\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getCourseVersionsAsync
     *
     * Get details on a course's versions.
     *
     * @param  string $course_id (required)
     * @param  \DateTime $since Only items updated since the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used. (optional)
     * @param  \DateTime $until Only items updated before the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used. (optional)
     * @param  bool $include_registration_count Include the registration count in the results (optional, default to false)
     * @param  bool $include_course_metadata Include course metadata in the results. If the course has no metadata, adding this parameter has no effect. (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCourseVersionsAsync($course_id, $since = null, $until = null, $include_registration_count = 'false', $include_course_metadata = 'false')
    {
        return $this->getCourseVersionsAsyncWithHttpInfo($course_id, $since, $until, $include_registration_count, $include_course_metadata)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCourseVersionsAsyncWithHttpInfo
     *
     * Get details on a course's versions.
     *
     * @param  string $course_id (required)
     * @param  \DateTime $since Only items updated since the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used. (optional)
     * @param  \DateTime $until Only items updated before the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used. (optional)
     * @param  bool $include_registration_count Include the registration count in the results (optional, default to false)
     * @param  bool $include_course_metadata Include course metadata in the results. If the course has no metadata, adding this parameter has no effect. (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCourseVersionsAsyncWithHttpInfo($course_id, $since = null, $until = null, $include_registration_count = 'false', $include_course_metadata = 'false')
    {
        $returnType = '\RusticiSoftware\Cloud\V2\Model\CourseListNonPagedSchema';
        $request = $this->getCourseVersionsRequest($course_id, $since, $until, $include_registration_count, $include_course_metadata);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCourseVersions'
     *
     * @param  string $course_id (required)
     * @param  \DateTime $since Only items updated since the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used. (optional)
     * @param  \DateTime $until Only items updated before the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used. (optional)
     * @param  bool $include_registration_count Include the registration count in the results (optional, default to false)
     * @param  bool $include_course_metadata Include course metadata in the results. If the course has no metadata, adding this parameter has no effect. (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getCourseVersionsRequest($course_id, $since = null, $until = null, $include_registration_count = 'false', $include_course_metadata = 'false')
    {
        // verify the required parameter 'course_id' is set
        if ($course_id === null || (is_array($course_id) && count($course_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $course_id when calling getCourseVersions'
            );
        }

        $resourcePath = '/courses/{courseId}/versions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($since !== null) {
            $queryParams['since'] = ObjectSerializer::toQueryValue($since);
        }
        // query params
        if ($until !== null) {
            $queryParams['until'] = ObjectSerializer::toQueryValue($until);
        }
        // query params
        if ($include_registration_count !== null) {
            $queryParams['includeRegistrationCount'] = ObjectSerializer::toQueryValue($include_registration_count);
        }
        // query params
        if ($include_course_metadata !== null) {
            $queryParams['includeCourseMetadata'] = ObjectSerializer::toQueryValue($include_course_metadata);
        }

        // path params
        if ($course_id !== null) {
            $resourcePath = str_replace(
                '{' . 'courseId' . '}',
                ObjectSerializer::toPathValue($course_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCourses
     *
     * Get all courses.
     *
     * @param  string $more Value for this parameter will be provided in the &#39;more&#39; property of registration lists, where needed. An opaque value, construction and parsing may change without notice. (optional)
     * @param  \DateTime $since Only items updated since the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used. (optional)
     * @param  \DateTime $until Only items updated before the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used. (optional)
     * @param  string $filter Optional string which filters results by a specified field (described by filterBy). (optional)
     * @param  string $filter_by Optional enum parameter for specifying the field on which to run the filter.  Defaults to course_id. (optional)
     * @param  string $order_by Optional enum parameter for specifying the field and order by which to sort the results.  Defaults to creation_date_desc. (optional)
     * @param  bool $include_registration_count Include the registration count in the results (optional, default to false)
     * @param  bool $include_course_metadata Include course metadata in the results. If the course has no metadata, adding this parameter has no effect. (optional, default to false)
     * @param  string[] $tags tags (optional)
     *
     * @throws \RusticiSoftware\Cloud\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \RusticiSoftware\Cloud\V2\Model\CourseListSchema
     */
    public function getCourses($more = null, $since = null, $until = null, $filter = null, $filter_by = null, $order_by = null, $include_registration_count = 'false', $include_course_metadata = 'false', $tags = null)
    {
        list($response) = $this->getCoursesWithHttpInfo($more, $since, $until, $filter, $filter_by, $order_by, $include_registration_count, $include_course_metadata, $tags);
        return $response;
    }

    /**
     * Operation getCoursesWithHttpInfo
     *
     * Get all courses.
     *
     * @param  string $more Value for this parameter will be provided in the &#39;more&#39; property of registration lists, where needed. An opaque value, construction and parsing may change without notice. (optional)
     * @param  \DateTime $since Only items updated since the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used. (optional)
     * @param  \DateTime $until Only items updated before the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used. (optional)
     * @param  string $filter Optional string which filters results by a specified field (described by filterBy). (optional)
     * @param  string $filter_by Optional enum parameter for specifying the field on which to run the filter.  Defaults to course_id. (optional)
     * @param  string $order_by Optional enum parameter for specifying the field and order by which to sort the results.  Defaults to creation_date_desc. (optional)
     * @param  bool $include_registration_count Include the registration count in the results (optional, default to false)
     * @param  bool $include_course_metadata Include course metadata in the results. If the course has no metadata, adding this parameter has no effect. (optional, default to false)
     * @param  string[] $tags (optional)
     *
     * @throws \RusticiSoftware\Cloud\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \RusticiSoftware\Cloud\V2\Model\CourseListSchema, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCoursesWithHttpInfo($more = null, $since = null, $until = null, $filter = null, $filter_by = null, $order_by = null, $include_registration_count = 'false', $include_course_metadata = 'false', $tags = null)
    {
        $returnType = '\RusticiSoftware\Cloud\V2\Model\CourseListSchema';
        $request = $this->getCoursesRequest($more, $since, $until, $filter, $filter_by, $order_by, $include_registration_count, $include_course_metadata, $tags);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Cloud\V2\Model\CourseListSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Cloud\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getCoursesAsync
     *
     * Get all courses.
     *
     * @param  string $more Value for this parameter will be provided in the &#39;more&#39; property of registration lists, where needed. An opaque value, construction and parsing may change without notice. (optional)
     * @param  \DateTime $since Only items updated since the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used. (optional)
     * @param  \DateTime $until Only items updated before the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used. (optional)
     * @param  string $filter Optional string which filters results by a specified field (described by filterBy). (optional)
     * @param  string $filter_by Optional enum parameter for specifying the field on which to run the filter.  Defaults to course_id. (optional)
     * @param  string $order_by Optional enum parameter for specifying the field and order by which to sort the results.  Defaults to creation_date_desc. (optional)
     * @param  bool $include_registration_count Include the registration count in the results (optional, default to false)
     * @param  bool $include_course_metadata Include course metadata in the results. If the course has no metadata, adding this parameter has no effect. (optional, default to false)
     * @param  string[] $tags (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCoursesAsync($more = null, $since = null, $until = null, $filter = null, $filter_by = null, $order_by = null, $include_registration_count = 'false', $include_course_metadata = 'false', $tags = null)
    {
        return $this->getCoursesAsyncWithHttpInfo($more, $since, $until, $filter, $filter_by, $order_by, $include_registration_count, $include_course_metadata, $tags)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCoursesAsyncWithHttpInfo
     *
     * Get all courses.
     *
     * @param  string $more Value for this parameter will be provided in the &#39;more&#39; property of registration lists, where needed. An opaque value, construction and parsing may change without notice. (optional)
     * @param  \DateTime $since Only items updated since the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used. (optional)
     * @param  \DateTime $until Only items updated before the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used. (optional)
     * @param  string $filter Optional string which filters results by a specified field (described by filterBy). (optional)
     * @param  string $filter_by Optional enum parameter for specifying the field on which to run the filter.  Defaults to course_id. (optional)
     * @param  string $order_by Optional enum parameter for specifying the field and order by which to sort the results.  Defaults to creation_date_desc. (optional)
     * @param  bool $include_registration_count Include the registration count in the results (optional, default to false)
     * @param  bool $include_course_metadata Include course metadata in the results. If the course has no metadata, adding this parameter has no effect. (optional, default to false)
     * @param  string[] $tags (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCoursesAsyncWithHttpInfo($more = null, $since = null, $until = null, $filter = null, $filter_by = null, $order_by = null, $include_registration_count = 'false', $include_course_metadata = 'false', $tags = null)
    {
        $returnType = '\RusticiSoftware\Cloud\V2\Model\CourseListSchema';
        $request = $this->getCoursesRequest($more, $since, $until, $filter, $filter_by, $order_by, $include_registration_count, $include_course_metadata, $tags);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCourses'
     *
     * @param  string $more Value for this parameter will be provided in the &#39;more&#39; property of registration lists, where needed. An opaque value, construction and parsing may change without notice. (optional)
     * @param  \DateTime $since Only items updated since the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used. (optional)
     * @param  \DateTime $until Only items updated before the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used. (optional)
     * @param  string $filter Optional string which filters results by a specified field (described by filterBy). (optional)
     * @param  string $filter_by Optional enum parameter for specifying the field on which to run the filter.  Defaults to course_id. (optional)
     * @param  string $order_by Optional enum parameter for specifying the field and order by which to sort the results.  Defaults to creation_date_desc. (optional)
     * @param  bool $include_registration_count Include the registration count in the results (optional, default to false)
     * @param  bool $include_course_metadata Include course metadata in the results. If the course has no metadata, adding this parameter has no effect. (optional, default to false)
     * @param  string[] $tags (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getCoursesRequest($more = null, $since = null, $until = null, $filter = null, $filter_by = null, $order_by = null, $include_registration_count = 'false', $include_course_metadata = 'false', $tags = null)
    {

        $resourcePath = '/courses';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($more !== null) {
            $queryParams['more'] = ObjectSerializer::toQueryValue($more);
        }
        // query params
        if ($since !== null) {
            $queryParams['since'] = ObjectSerializer::toQueryValue($since);
        }
        // query params
        if ($until !== null) {
            $queryParams['until'] = ObjectSerializer::toQueryValue($until);
        }
        // query params
        if ($filter !== null) {
            $queryParams['filter'] = ObjectSerializer::toQueryValue($filter);
        }
        // query params
        if ($filter_by !== null) {
            $queryParams['filterBy'] = ObjectSerializer::toQueryValue($filter_by);
        }
        // query params
        if ($order_by !== null) {
            $queryParams['orderBy'] = ObjectSerializer::toQueryValue($order_by);
        }
        // query params
        if ($include_registration_count !== null) {
            $queryParams['includeRegistrationCount'] = ObjectSerializer::toQueryValue($include_registration_count);
        }
        // query params
        if ($include_course_metadata !== null) {
            $queryParams['includeCourseMetadata'] = ObjectSerializer::toQueryValue($include_course_metadata);
        }
        // query params
        if (is_array($tags)) {
            $queryParams['tags'] = $tags;
        } else
        if ($tags !== null) {
            $queryParams['tags'] = ObjectSerializer::toQueryValue($tags);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getImportJobStatus
     *
     * Get course import job status.
     *
     * @param  string $import_job_id Id received when the import job was submitted to the importJobs resource. (required)
     *
     * @throws \RusticiSoftware\Cloud\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \RusticiSoftware\Cloud\V2\Model\ImportJobResultSchema
     */
    public function getImportJobStatus($import_job_id)
    {
        list($response) = $this->getImportJobStatusWithHttpInfo($import_job_id);
        return $response;
    }

    /**
     * Operation getImportJobStatusWithHttpInfo
     *
     * Get course import job status.
     *
     * @param  string $import_job_id Id received when the import job was submitted to the importJobs resource. (required)
     *
     * @throws \RusticiSoftware\Cloud\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \RusticiSoftware\Cloud\V2\Model\ImportJobResultSchema, HTTP status code, HTTP response headers (array of strings)
     */
    public function getImportJobStatusWithHttpInfo($import_job_id)
    {
        $returnType = '\RusticiSoftware\Cloud\V2\Model\ImportJobResultSchema';
        $request = $this->getImportJobStatusRequest($import_job_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Cloud\V2\Model\ImportJobResultSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Cloud\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Cloud\V2\Model\ResponseError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getImportJobStatusAsync
     *
     * Get course import job status.
     *
     * @param  string $import_job_id Id received when the import job was submitted to the importJobs resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getImportJobStatusAsync($import_job_id)
    {
        return $this->getImportJobStatusAsyncWithHttpInfo($import_job_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getImportJobStatusAsyncWithHttpInfo
     *
     * Get course import job status.
     *
     * @param  string $import_job_id Id received when the import job was submitted to the importJobs resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getImportJobStatusAsyncWithHttpInfo($import_job_id)
    {
        $returnType = '\RusticiSoftware\Cloud\V2\Model\ImportJobResultSchema';
        $request = $this->getImportJobStatusRequest($import_job_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getImportJobStatus'
     *
     * @param  string $import_job_id Id received when the import job was submitted to the importJobs resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getImportJobStatusRequest($import_job_id)
    {
        // verify the required parameter 'import_job_id' is set
        if ($import_job_id === null || (is_array($import_job_id) && count($import_job_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $import_job_id when calling getImportJobStatus'
            );
        }

        $resourcePath = '/courses/importJobs/{importJobId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($import_job_id !== null) {
            $resourcePath = str_replace(
                '{' . 'importJobId' . '}',
                ObjectSerializer::toPathValue($import_job_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putCourseTags
     *
     * Set course tags.
     *
     * @param  string $course_id course_id (required)
     * @param  \RusticiSoftware\Cloud\V2\Model\TagListSchema $tags tags (required)
     *
     * @throws \RusticiSoftware\Cloud\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function putCourseTags($course_id, $tags)
    {
        $this->putCourseTagsWithHttpInfo($course_id, $tags);
    }

    /**
     * Operation putCourseTagsWithHttpInfo
     *
     * Set course tags.
     *
     * @param  string $course_id (required)
     * @param  \RusticiSoftware\Cloud\V2\Model\TagListSchema $tags (required)
     *
     * @throws \RusticiSoftware\Cloud\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function putCourseTagsWithHttpInfo($course_id, $tags)
    {
        $returnType = '';
        $request = $this->putCourseTagsRequest($course_id, $tags);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Cloud\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Cloud\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putCourseTagsAsync
     *
     * Set course tags.
     *
     * @param  string $course_id (required)
     * @param  \RusticiSoftware\Cloud\V2\Model\TagListSchema $tags (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putCourseTagsAsync($course_id, $tags)
    {
        return $this->putCourseTagsAsyncWithHttpInfo($course_id, $tags)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putCourseTagsAsyncWithHttpInfo
     *
     * Set course tags.
     *
     * @param  string $course_id (required)
     * @param  \RusticiSoftware\Cloud\V2\Model\TagListSchema $tags (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putCourseTagsAsyncWithHttpInfo($course_id, $tags)
    {
        $returnType = '';
        $request = $this->putCourseTagsRequest($course_id, $tags);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putCourseTags'
     *
     * @param  string $course_id (required)
     * @param  \RusticiSoftware\Cloud\V2\Model\TagListSchema $tags (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putCourseTagsRequest($course_id, $tags)
    {
        // verify the required parameter 'course_id' is set
        if ($course_id === null || (is_array($course_id) && count($course_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $course_id when calling putCourseTags'
            );
        }
        // verify the required parameter 'tags' is set
        if ($tags === null || (is_array($tags) && count($tags) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $tags when calling putCourseTags'
            );
        }

        $resourcePath = '/courses/{courseId}/tags';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($course_id !== null) {
            $resourcePath = str_replace(
                '{' . 'courseId' . '}',
                ObjectSerializer::toPathValue($course_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($tags)) {
            $_tempBody = $tags;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putCourseTagsBatch
     *
     * Set tags on courses.
     *
     * @param  \RusticiSoftware\Cloud\V2\Model\BatchTagsSchema $batch Object representing an array of ids to apply an array of tags to. (required)
     *
     * @throws \RusticiSoftware\Cloud\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function putCourseTagsBatch($batch)
    {
        $this->putCourseTagsBatchWithHttpInfo($batch);
    }

    /**
     * Operation putCourseTagsBatchWithHttpInfo
     *
     * Set tags on courses.
     *
     * @param  \RusticiSoftware\Cloud\V2\Model\BatchTagsSchema $batch Object representing an array of ids to apply an array of tags to. (required)
     *
     * @throws \RusticiSoftware\Cloud\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function putCourseTagsBatchWithHttpInfo($batch)
    {
        $returnType = '';
        $request = $this->putCourseTagsBatchRequest($batch);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Cloud\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Cloud\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putCourseTagsBatchAsync
     *
     * Set tags on courses.
     *
     * @param  \RusticiSoftware\Cloud\V2\Model\BatchTagsSchema $batch Object representing an array of ids to apply an array of tags to. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putCourseTagsBatchAsync($batch)
    {
        return $this->putCourseTagsBatchAsyncWithHttpInfo($batch)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putCourseTagsBatchAsyncWithHttpInfo
     *
     * Set tags on courses.
     *
     * @param  \RusticiSoftware\Cloud\V2\Model\BatchTagsSchema $batch Object representing an array of ids to apply an array of tags to. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putCourseTagsBatchAsyncWithHttpInfo($batch)
    {
        $returnType = '';
        $request = $this->putCourseTagsBatchRequest($batch);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putCourseTagsBatch'
     *
     * @param  \RusticiSoftware\Cloud\V2\Model\BatchTagsSchema $batch Object representing an array of ids to apply an array of tags to. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putCourseTagsBatchRequest($batch)
    {
        // verify the required parameter 'batch' is set
        if ($batch === null || (is_array($batch) && count($batch) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $batch when calling putCourseTagsBatch'
            );
        }

        $resourcePath = '/courses/tags';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($batch)) {
            $_tempBody = $batch;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation setCourseConfiguration
     *
     * Set course configuration.
     *
     * @param  string $course_id course_id (required)
     * @param  \RusticiSoftware\Cloud\V2\Model\SettingsPostSchema $configuration_settings configuration_settings (required)
     *
     * @throws \RusticiSoftware\Cloud\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function setCourseConfiguration($course_id, $configuration_settings)
    {
        $this->setCourseConfigurationWithHttpInfo($course_id, $configuration_settings);
    }

    /**
     * Operation setCourseConfigurationWithHttpInfo
     *
     * Set course configuration.
     *
     * @param  string $course_id (required)
     * @param  \RusticiSoftware\Cloud\V2\Model\SettingsPostSchema $configuration_settings (required)
     *
     * @throws \RusticiSoftware\Cloud\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function setCourseConfigurationWithHttpInfo($course_id, $configuration_settings)
    {
        $returnType = '';
        $request = $this->setCourseConfigurationRequest($course_id, $configuration_settings);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Cloud\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Cloud\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation setCourseConfigurationAsync
     *
     * Set course configuration.
     *
     * @param  string $course_id (required)
     * @param  \RusticiSoftware\Cloud\V2\Model\SettingsPostSchema $configuration_settings (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setCourseConfigurationAsync($course_id, $configuration_settings)
    {
        return $this->setCourseConfigurationAsyncWithHttpInfo($course_id, $configuration_settings)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation setCourseConfigurationAsyncWithHttpInfo
     *
     * Set course configuration.
     *
     * @param  string $course_id (required)
     * @param  \RusticiSoftware\Cloud\V2\Model\SettingsPostSchema $configuration_settings (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setCourseConfigurationAsyncWithHttpInfo($course_id, $configuration_settings)
    {
        $returnType = '';
        $request = $this->setCourseConfigurationRequest($course_id, $configuration_settings);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'setCourseConfiguration'
     *
     * @param  string $course_id (required)
     * @param  \RusticiSoftware\Cloud\V2\Model\SettingsPostSchema $configuration_settings (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function setCourseConfigurationRequest($course_id, $configuration_settings)
    {
        // verify the required parameter 'course_id' is set
        if ($course_id === null || (is_array($course_id) && count($course_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $course_id when calling setCourseConfiguration'
            );
        }
        // verify the required parameter 'configuration_settings' is set
        if ($configuration_settings === null || (is_array($configuration_settings) && count($configuration_settings) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $configuration_settings when calling setCourseConfiguration'
            );
        }

        $resourcePath = '/courses/{courseId}/configuration';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($course_id !== null) {
            $resourcePath = str_replace(
                '{' . 'courseId' . '}',
                ObjectSerializer::toPathValue($course_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($configuration_settings)) {
            $_tempBody = $configuration_settings;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation setCourseTitle
     *
     * Set the title of a course.
     *
     * @param  string $course_id course_id (required)
     * @param  \RusticiSoftware\Cloud\V2\Model\TitleSchema $title title (required)
     *
     * @throws \RusticiSoftware\Cloud\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function setCourseTitle($course_id, $title)
    {
        $this->setCourseTitleWithHttpInfo($course_id, $title);
    }

    /**
     * Operation setCourseTitleWithHttpInfo
     *
     * Set the title of a course.
     *
     * @param  string $course_id (required)
     * @param  \RusticiSoftware\Cloud\V2\Model\TitleSchema $title (required)
     *
     * @throws \RusticiSoftware\Cloud\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function setCourseTitleWithHttpInfo($course_id, $title)
    {
        $returnType = '';
        $request = $this->setCourseTitleRequest($course_id, $title);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Cloud\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Cloud\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation setCourseTitleAsync
     *
     * Set the title of a course.
     *
     * @param  string $course_id (required)
     * @param  \RusticiSoftware\Cloud\V2\Model\TitleSchema $title (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setCourseTitleAsync($course_id, $title)
    {
        return $this->setCourseTitleAsyncWithHttpInfo($course_id, $title)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation setCourseTitleAsyncWithHttpInfo
     *
     * Set the title of a course.
     *
     * @param  string $course_id (required)
     * @param  \RusticiSoftware\Cloud\V2\Model\TitleSchema $title (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setCourseTitleAsyncWithHttpInfo($course_id, $title)
    {
        $returnType = '';
        $request = $this->setCourseTitleRequest($course_id, $title);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'setCourseTitle'
     *
     * @param  string $course_id (required)
     * @param  \RusticiSoftware\Cloud\V2\Model\TitleSchema $title (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function setCourseTitleRequest($course_id, $title)
    {
        // verify the required parameter 'course_id' is set
        if ($course_id === null || (is_array($course_id) && count($course_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $course_id when calling setCourseTitle'
            );
        }
        // verify the required parameter 'title' is set
        if ($title === null || (is_array($title) && count($title) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $title when calling setCourseTitle'
            );
        }

        $resourcePath = '/courses/{courseId}/title';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($course_id !== null) {
            $resourcePath = str_replace(
                '{' . 'courseId' . '}',
                ObjectSerializer::toPathValue($course_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($title)) {
            $_tempBody = $title;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation setCourseVersionConfiguration
     *
     * Set configuration for a version of a course.
     *
     * @param  string $course_id course_id (required)
     * @param  int $version_id The course version (required)
     * @param  \RusticiSoftware\Cloud\V2\Model\SettingsPostSchema $configuration_settings configuration_settings (required)
     *
     * @throws \RusticiSoftware\Cloud\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function setCourseVersionConfiguration($course_id, $version_id, $configuration_settings)
    {
        $this->setCourseVersionConfigurationWithHttpInfo($course_id, $version_id, $configuration_settings);
    }

    /**
     * Operation setCourseVersionConfigurationWithHttpInfo
     *
     * Set configuration for a version of a course.
     *
     * @param  string $course_id (required)
     * @param  int $version_id The course version (required)
     * @param  \RusticiSoftware\Cloud\V2\Model\SettingsPostSchema $configuration_settings (required)
     *
     * @throws \RusticiSoftware\Cloud\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function setCourseVersionConfigurationWithHttpInfo($course_id, $version_id, $configuration_settings)
    {
        $returnType = '';
        $request = $this->setCourseVersionConfigurationRequest($course_id, $version_id, $configuration_settings);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Cloud\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Cloud\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation setCourseVersionConfigurationAsync
     *
     * Set configuration for a version of a course.
     *
     * @param  string $course_id (required)
     * @param  int $version_id The course version (required)
     * @param  \RusticiSoftware\Cloud\V2\Model\SettingsPostSchema $configuration_settings (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setCourseVersionConfigurationAsync($course_id, $version_id, $configuration_settings)
    {
        return $this->setCourseVersionConfigurationAsyncWithHttpInfo($course_id, $version_id, $configuration_settings)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation setCourseVersionConfigurationAsyncWithHttpInfo
     *
     * Set configuration for a version of a course.
     *
     * @param  string $course_id (required)
     * @param  int $version_id The course version (required)
     * @param  \RusticiSoftware\Cloud\V2\Model\SettingsPostSchema $configuration_settings (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setCourseVersionConfigurationAsyncWithHttpInfo($course_id, $version_id, $configuration_settings)
    {
        $returnType = '';
        $request = $this->setCourseVersionConfigurationRequest($course_id, $version_id, $configuration_settings);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'setCourseVersionConfiguration'
     *
     * @param  string $course_id (required)
     * @param  int $version_id The course version (required)
     * @param  \RusticiSoftware\Cloud\V2\Model\SettingsPostSchema $configuration_settings (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function setCourseVersionConfigurationRequest($course_id, $version_id, $configuration_settings)
    {
        // verify the required parameter 'course_id' is set
        if ($course_id === null || (is_array($course_id) && count($course_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $course_id when calling setCourseVersionConfiguration'
            );
        }
        // verify the required parameter 'version_id' is set
        if ($version_id === null || (is_array($version_id) && count($version_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version_id when calling setCourseVersionConfiguration'
            );
        }
        // verify the required parameter 'configuration_settings' is set
        if ($configuration_settings === null || (is_array($configuration_settings) && count($configuration_settings) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $configuration_settings when calling setCourseVersionConfiguration'
            );
        }

        $resourcePath = '/courses/{courseId}/versions/{versionId}/configuration';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($course_id !== null) {
            $resourcePath = str_replace(
                '{' . 'courseId' . '}',
                ObjectSerializer::toPathValue($course_id),
                $resourcePath
            );
        }
        // path params
        if ($version_id !== null) {
            $resourcePath = str_replace(
                '{' . 'versionId' . '}',
                ObjectSerializer::toPathValue($version_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($configuration_settings)) {
            $_tempBody = $configuration_settings;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
